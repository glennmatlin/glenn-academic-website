<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>python3_logging_cookbook – Glenn Matlin</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-4b21671d97fbeace61f61eff8c37c710.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Glenn Matlin</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-knowledge-base" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Knowledge Base</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-knowledge-base">    
        <li>
    <a class="dropdown-item" href="../../knowledgebase/cheatsheets/tmux.html">
 <span class="dropdown-text">tmux Cheatsheet</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../knowledgebase/cheatsheets/marp.html">
 <span class="dropdown-text">Marp Guide</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">Python Logging</li>
        <li>
    <a class="dropdown-item" href="../../knowledgebase/python/python3_logging_howto.html">
 <span class="dropdown-text">Logging How-To</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../knowledgebase/python/python3_logging_cookbook.html">
 <span class="dropdown-text">Logging Cookbook</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../knowledgebase/python/python3_logging_api.html">
 <span class="dropdown-text">Logging API</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/gmatlin"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com/in/glennmatlin"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:glenn@glennmatlin.doctor"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#logging-cookbook-python-3.13.1-documentation" id="toc-logging-cookbook-python-3.13.1-documentation" class="nav-link active" data-scroll-target="#logging-cookbook-python-3.13.1-documentation">Logging Cookbook — Python 3.13.1 documentation</a>
  <ul class="collapse">
  <li><a href="#using-logging-in-multiple-modules" id="toc-using-logging-in-multiple-modules" class="nav-link" data-scroll-target="#using-logging-in-multiple-modules">Using logging in multiple modules¶</a></li>
  <li><a href="#logging-from-multiple-threads" id="toc-logging-from-multiple-threads" class="nav-link" data-scroll-target="#logging-from-multiple-threads">Logging from multiple threads¶</a></li>
  <li><a href="#multiple-handlers-and-formatters" id="toc-multiple-handlers-and-formatters" class="nav-link" data-scroll-target="#multiple-handlers-and-formatters">Multiple handlers and formatters¶</a></li>
  <li><a href="#logging-to-multiple-destinations" id="toc-logging-to-multiple-destinations" class="nav-link" data-scroll-target="#logging-to-multiple-destinations">Logging to multiple destinations¶</a></li>
  <li><a href="#custom-handling-of-levels" id="toc-custom-handling-of-levels" class="nav-link" data-scroll-target="#custom-handling-of-levels">Custom handling of levels¶</a></li>
  <li><a href="#configuration-server-example" id="toc-configuration-server-example" class="nav-link" data-scroll-target="#configuration-server-example">Configuration server example¶</a></li>
  <li><a href="#dealing-with-handlers-that-block" id="toc-dealing-with-handlers-that-block" class="nav-link" data-scroll-target="#dealing-with-handlers-that-block">Dealing with handlers that block¶</a></li>
  <li><a href="#sending-and-receiving-logging-events-across-a-network" id="toc-sending-and-receiving-logging-events-across-a-network" class="nav-link" data-scroll-target="#sending-and-receiving-logging-events-across-a-network">Sending and receiving logging events across a network¶</a>
  <ul class="collapse">
  <li><a href="#running-a-logging-socket-listener-in-production" id="toc-running-a-logging-socket-listener-in-production" class="nav-link" data-scroll-target="#running-a-logging-socket-listener-in-production">Running a logging socket listener in production¶</a></li>
  </ul></li>
  <li><a href="#adding-contextual-information-to-your-logging-output" id="toc-adding-contextual-information-to-your-logging-output" class="nav-link" data-scroll-target="#adding-contextual-information-to-your-logging-output">Adding contextual information to your logging output¶</a>
  <ul class="collapse">
  <li><a href="#using-loggeradapters-to-impart-contextual-information" id="toc-using-loggeradapters-to-impart-contextual-information" class="nav-link" data-scroll-target="#using-loggeradapters-to-impart-contextual-information">Using LoggerAdapters to impart contextual information¶</a></li>
  <li><a href="#using-filters-to-impart-contextual-information" id="toc-using-filters-to-impart-contextual-information" class="nav-link" data-scroll-target="#using-filters-to-impart-contextual-information">Using Filters to impart contextual information¶</a></li>
  </ul></li>
  <li><a href="#use-of-contextvars" id="toc-use-of-contextvars" class="nav-link" data-scroll-target="#use-of-contextvars">Use of <code>contextvars</code>¶</a></li>
  <li><a href="#imparting-contextual-information-in-handlers" id="toc-imparting-contextual-information-in-handlers" class="nav-link" data-scroll-target="#imparting-contextual-information-in-handlers">Imparting contextual information in handlers¶</a></li>
  <li><a href="#logging-to-a-single-file-from-multiple-processes" id="toc-logging-to-a-single-file-from-multiple-processes" class="nav-link" data-scroll-target="#logging-to-a-single-file-from-multiple-processes">Logging to a single file from multiple processes¶</a>
  <ul class="collapse">
  <li><a href="#using-concurrent.futures.processpoolexecutor" id="toc-using-concurrent.futures.processpoolexecutor" class="nav-link" data-scroll-target="#using-concurrent.futures.processpoolexecutor">Using concurrent.futures.ProcessPoolExecutor¶</a></li>
  <li><a href="#deploying-web-applications-using-gunicorn-and-uwsgi" id="toc-deploying-web-applications-using-gunicorn-and-uwsgi" class="nav-link" data-scroll-target="#deploying-web-applications-using-gunicorn-and-uwsgi">Deploying Web applications using Gunicorn and uWSGI¶</a></li>
  </ul></li>
  <li><a href="#using-file-rotation" id="toc-using-file-rotation" class="nav-link" data-scroll-target="#using-file-rotation">Using file rotation¶</a></li>
  <li><a href="#use-of-alternative-formatting-styles" id="toc-use-of-alternative-formatting-styles" class="nav-link" data-scroll-target="#use-of-alternative-formatting-styles">Use of alternative formatting styles¶</a></li>
  <li><a href="#customizing-logrecord" id="toc-customizing-logrecord" class="nav-link" data-scroll-target="#customizing-logrecord">Customizing <code>LogRecord</code>¶</a></li>
  <li><a href="#subclassing-queuehandler-and-queuelistener--a-zeromq-example" id="toc-subclassing-queuehandler-and-queuelistener--a-zeromq-example" class="nav-link" data-scroll-target="#subclassing-queuehandler-and-queuelistener--a-zeromq-example">Subclassing QueueHandler and QueueListener- a ZeroMQ example¶</a>
  <ul class="collapse">
  <li><a href="#subclass-queuehandler" id="toc-subclass-queuehandler" class="nav-link" data-scroll-target="#subclass-queuehandler">Subclass <code>QueueHandler</code>¶</a></li>
  <li><a href="#subclass-queuelistener" id="toc-subclass-queuelistener" class="nav-link" data-scroll-target="#subclass-queuelistener">Subclass <code>QueueListener</code>¶</a></li>
  </ul></li>
  <li><a href="#subclassing-queuehandler-and-queuelistener--a-pynng-example" id="toc-subclassing-queuehandler-and-queuelistener--a-pynng-example" class="nav-link" data-scroll-target="#subclassing-queuehandler-and-queuelistener--a-pynng-example">Subclassing QueueHandler and QueueListener- a <code>pynng</code> example¶</a>
  <ul class="collapse">
  <li><a href="#subclass-queuelistener-1" id="toc-subclass-queuelistener-1" class="nav-link" data-scroll-target="#subclass-queuelistener-1">Subclass <code>QueueListener</code>¶</a></li>
  <li><a href="#subclass-queuehandler-1" id="toc-subclass-queuehandler-1" class="nav-link" data-scroll-target="#subclass-queuehandler-1">Subclass <code>QueueHandler</code>¶</a></li>
  </ul></li>
  <li><a href="#an-example-dictionary-based-configuration" id="toc-an-example-dictionary-based-configuration" class="nav-link" data-scroll-target="#an-example-dictionary-based-configuration">An example dictionary-based configuration¶</a></li>
  <li><a href="#using-a-rotator-and-namer-to-customize-log-rotation-processing" id="toc-using-a-rotator-and-namer-to-customize-log-rotation-processing" class="nav-link" data-scroll-target="#using-a-rotator-and-namer-to-customize-log-rotation-processing">Using a rotator and namer to customize log rotation processing¶</a></li>
  <li><a href="#a-more-elaborate-multiprocessing-example" id="toc-a-more-elaborate-multiprocessing-example" class="nav-link" data-scroll-target="#a-more-elaborate-multiprocessing-example">A more elaborate multiprocessing example¶</a></li>
  <li><a href="#inserting-a-bom-into-messages-sent-to-a-sysloghandler" id="toc-inserting-a-bom-into-messages-sent-to-a-sysloghandler" class="nav-link" data-scroll-target="#inserting-a-bom-into-messages-sent-to-a-sysloghandler">Inserting a BOM into messages sent to a SysLogHandler¶</a></li>
  <li><a href="#implementing-structured-logging" id="toc-implementing-structured-logging" class="nav-link" data-scroll-target="#implementing-structured-logging">Implementing structured logging¶</a></li>
  <li><a href="#customizing-handlers-with-dictconfig" id="toc-customizing-handlers-with-dictconfig" class="nav-link" data-scroll-target="#customizing-handlers-with-dictconfig">Customizing handlers with <code>dictConfig()</code>¶</a></li>
  <li><a href="#using-particular-formatting-styles-throughout-your-application" id="toc-using-particular-formatting-styles-throughout-your-application" class="nav-link" data-scroll-target="#using-particular-formatting-styles-throughout-your-application">Using particular formatting styles throughout your application¶</a>
  <ul class="collapse">
  <li><a href="#using-logrecord-factories" id="toc-using-logrecord-factories" class="nav-link" data-scroll-target="#using-logrecord-factories">Using LogRecord factories¶</a></li>
  <li><a href="#using-custom-message-objects" id="toc-using-custom-message-objects" class="nav-link" data-scroll-target="#using-custom-message-objects">Using custom message objects¶</a></li>
  </ul></li>
  <li><a href="#configuring-filters-with-dictconfig" id="toc-configuring-filters-with-dictconfig" class="nav-link" data-scroll-target="#configuring-filters-with-dictconfig">Configuring filters with <code>dictConfig()</code>¶</a></li>
  <li><a href="#customized-exception-formatting" id="toc-customized-exception-formatting" class="nav-link" data-scroll-target="#customized-exception-formatting">Customized exception formatting¶</a></li>
  <li><a href="#speaking-logging-messages" id="toc-speaking-logging-messages" class="nav-link" data-scroll-target="#speaking-logging-messages">Speaking logging messages¶</a></li>
  <li><a href="#buffering-logging-messages-and-outputting-them-conditionally" id="toc-buffering-logging-messages-and-outputting-them-conditionally" class="nav-link" data-scroll-target="#buffering-logging-messages-and-outputting-them-conditionally">Buffering logging messages and outputting them conditionally¶</a></li>
  <li><a href="#sending-logging-messages-to-email-with-buffering" id="toc-sending-logging-messages-to-email-with-buffering" class="nav-link" data-scroll-target="#sending-logging-messages-to-email-with-buffering">Sending logging messages to email, with buffering¶</a></li>
  <li><a href="#formatting-times-using-utc-gmt-via-configuration" id="toc-formatting-times-using-utc-gmt-via-configuration" class="nav-link" data-scroll-target="#formatting-times-using-utc-gmt-via-configuration">Formatting times using UTC (GMT) via configuration¶</a></li>
  <li><a href="#using-a-context-manager-for-selective-logging" id="toc-using-a-context-manager-for-selective-logging" class="nav-link" data-scroll-target="#using-a-context-manager-for-selective-logging">Using a context manager for selective logging¶</a></li>
  <li><a href="#a-cli-application-starter-template" id="toc-a-cli-application-starter-template" class="nav-link" data-scroll-target="#a-cli-application-starter-template">A CLI application starter template¶</a></li>
  <li><a href="#a-qt-gui-for-logging" id="toc-a-qt-gui-for-logging" class="nav-link" data-scroll-target="#a-qt-gui-for-logging">A Qt GUI for logging¶</a></li>
  <li><a href="#logging-to-syslog-with-rfc5424-support" id="toc-logging-to-syslog-with-rfc5424-support" class="nav-link" data-scroll-target="#logging-to-syslog-with-rfc5424-support">Logging to syslog with RFC5424 support¶</a></li>
  <li><a href="#how-to-treat-a-logger-like-an-output-stream" id="toc-how-to-treat-a-logger-like-an-output-stream" class="nav-link" data-scroll-target="#how-to-treat-a-logger-like-an-output-stream">How to treat a logger like an output stream¶</a></li>
  <li><a href="#patterns-to-avoid" id="toc-patterns-to-avoid" class="nav-link" data-scroll-target="#patterns-to-avoid">Patterns to avoid¶</a>
  <ul class="collapse">
  <li><a href="#opening-the-same-log-file-multiple-times" id="toc-opening-the-same-log-file-multiple-times" class="nav-link" data-scroll-target="#opening-the-same-log-file-multiple-times">Opening the same log file multiple times¶</a></li>
  <li><a href="#using-loggers-as-attributes-in-a-class-or-passing-them-as-parameters" id="toc-using-loggers-as-attributes-in-a-class-or-passing-them-as-parameters" class="nav-link" data-scroll-target="#using-loggers-as-attributes-in-a-class-or-passing-them-as-parameters">Using loggers as attributes in a class or passing them as parameters¶</a></li>
  <li><a href="#adding-handlers-other-than-nullhandler-to-a-logger-in-a-library" id="toc-adding-handlers-other-than-nullhandler-to-a-logger-in-a-library" class="nav-link" data-scroll-target="#adding-handlers-other-than-nullhandler-to-a-logger-in-a-library">Adding handlers other than <code>NullHandler</code> to a logger in a library¶</a></li>
  <li><a href="#creating-a-lot-of-loggers" id="toc-creating-a-lot-of-loggers" class="nav-link" data-scroll-target="#creating-a-lot-of-loggers">Creating a lot of loggers¶</a></li>
  </ul></li>
  <li><a href="#other-resources" id="toc-other-resources" class="nav-link" data-scroll-target="#other-resources">Other resources¶</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="logging-cookbook-python-3.13.1-documentation" class="level1">
<h1>Logging Cookbook — Python 3.13.1 documentation</h1>
<p>This page contains a number of recipes related to logging, which have been found useful in the past. For links to tutorial and reference information, please see <a href="https://docs.python.org/3/howto/logging-cookbook.html#cookbook-ref-links">Other resources</a>.</p>
<section id="using-logging-in-multiple-modules" class="level2">
<h2 class="anchored" data-anchor-id="using-logging-in-multiple-modules">Using logging in multiple modules<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-logging-in-multiple-modules" title="Link to this heading">¶</a></h2>
<p>Multiple calls to <code>logging.getLogger('someLogger')</code> return a reference to the same logger object. This is true not only within the same module, but also across modules as long as it is in the same Python interpreter process. It is true for references to the same object; additionally, application code can define and configure a parent logger in one module and create (but not configure) a child logger in a separate module, and all logger calls to the child will pass up to the parent. Here is a main module:</p>
<pre><code>import logging
import auxiliary_module

# create logger with 'spam_application'
logger = logging.getLogger('spam_application')
logger.setLevel(logging.DEBUG)
# create file handler which logs even debug messages
fh = logging.FileHandler('spam.log')
fh.setLevel(logging.DEBUG)
# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.ERROR)
# create formatter and add it to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
ch.setFormatter(formatter)
# add the handlers to the logger
logger.addHandler(fh)
logger.addHandler(ch)

logger.info('creating an instance of auxiliary_module.Auxiliary')
a = auxiliary_module.Auxiliary()
logger.info('created an instance of auxiliary_module.Auxiliary')
logger.info('calling auxiliary_module.Auxiliary.do_something')
a.do_something()
logger.info('finished auxiliary_module.Auxiliary.do_something')
logger.info('calling auxiliary_module.some_function()')
auxiliary_module.some_function()
logger.info('done with auxiliary_module.some_function()')
</code></pre>
<p>Here is the auxiliary module:</p>
<pre><code>import logging

# create logger
module_logger = logging.getLogger('spam_application.auxiliary')

class Auxiliary:
    def __init__(self):
        self.logger = logging.getLogger('spam_application.auxiliary.Auxiliary')
        self.logger.info('creating an instance of Auxiliary')

    def do_something(self):
        self.logger.info('doing something')
        a = 1 + 1
        self.logger.info('done doing something')

def some_function():
    module_logger.info('received a call to "some_function"')
</code></pre>
<p>The output looks like this:</p>
<pre><code>2005-03-23 23:47:11,663 - spam_application - INFO -
   creating an instance of auxiliary_module.Auxiliary
2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -
   creating an instance of Auxiliary
2005-03-23 23:47:11,665 - spam_application - INFO -
   created an instance of auxiliary_module.Auxiliary
2005-03-23 23:47:11,668 - spam_application - INFO -
   calling auxiliary_module.Auxiliary.do_something
2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -
   doing something
2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -
   done doing something
2005-03-23 23:47:11,670 - spam_application - INFO -
   finished auxiliary_module.Auxiliary.do_something
2005-03-23 23:47:11,671 - spam_application - INFO -
   calling auxiliary_module.some_function()
2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -
   received a call to 'some_function'
2005-03-23 23:47:11,673 - spam_application - INFO -
   done with auxiliary_module.some_function()
</code></pre>
</section>
<section id="logging-from-multiple-threads" class="level2">
<h2 class="anchored" data-anchor-id="logging-from-multiple-threads">Logging from multiple threads<a href="https://docs.python.org/3/howto/logging-cookbook.html#logging-from-multiple-threads" title="Link to this heading">¶</a></h2>
<p>Logging from multiple threads requires no special effort. The following example shows logging from the main (initial) thread and another thread:</p>
<pre><code>import logging
import threading
import time

def worker(arg):
    while not arg['stop']:
        logging.debug('Hi from myfunc')
        time.sleep(0.5)

def main():
    logging.basicConfig(level=logging.DEBUG, format='%(relativeCreated)6d %(threadName)s %(message)s')
    info = {'stop': False}
    thread = threading.Thread(target=worker, args=(info,))
    thread.start()
    while True:
        try:
            logging.debug('Hello from main')
            time.sleep(0.75)
        except KeyboardInterrupt:
            info['stop'] = True
            break
    thread.join()

if __name__ == '__main__':
    main()
</code></pre>
<p>When run, the script should print something like the following:</p>
<pre><code>   0 Thread-1 Hi from myfunc
   3 MainThread Hello from main
 505 Thread-1 Hi from myfunc
 755 MainThread Hello from main
1007 Thread-1 Hi from myfunc
1507 MainThread Hello from main
1508 Thread-1 Hi from myfunc
2010 Thread-1 Hi from myfunc
2258 MainThread Hello from main
2512 Thread-1 Hi from myfunc
3009 MainThread Hello from main
3013 Thread-1 Hi from myfunc
3515 Thread-1 Hi from myfunc
3761 MainThread Hello from main
4017 Thread-1 Hi from myfunc
4513 MainThread Hello from main
4518 Thread-1 Hi from myfunc
</code></pre>
<p>This shows the logging output interspersed as one might expect. This approach works for more threads than shown here, of course.</p>
</section>
<section id="multiple-handlers-and-formatters" class="level2">
<h2 class="anchored" data-anchor-id="multiple-handlers-and-formatters">Multiple handlers and formatters<a href="https://docs.python.org/3/howto/logging-cookbook.html#multiple-handlers-and-formatters" title="Link to this heading">¶</a></h2>
<p>Loggers are plain Python objects. The <a href="https://docs.python.org/3/library/logging.html#logging.Logger.addHandler" title="logging.Logger.addHandler"><code>addHandler()</code></a> method has no minimum or maximum quota for the number of handlers you may add. Sometimes it will be beneficial for an application to log all messages of all severities to a text file while simultaneously logging errors or above to the console. To set this up, simply configure the appropriate handlers. The logging calls in the application code will remain unchanged. Here is a slight modification to the previous simple module-based configuration example:</p>
<pre><code>import logging

logger = logging.getLogger('simple_example')
logger.setLevel(logging.DEBUG)
# create file handler which logs even debug messages
fh = logging.FileHandler('spam.log')
fh.setLevel(logging.DEBUG)
# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.ERROR)
# create formatter and add it to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
fh.setFormatter(formatter)
# add the handlers to logger
logger.addHandler(ch)
logger.addHandler(fh)

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warning('warn message')
logger.error('error message')
logger.critical('critical message')
</code></pre>
<p>Notice that the ‘application’ code does not care about multiple handlers. All that changed was the addition and configuration of a new handler named <em>fh</em>.</p>
<p>The ability to create new handlers with higher- or lower-severity filters can be very helpful when writing and testing an application. Instead of using many <code>print</code> statements for debugging, use <code>logger.debug</code>: Unlike the print statements, which you will have to delete or comment out later, the logger.debug statements can remain intact in the source code and remain dormant until you need them again. At that time, the only change that needs to happen is to modify the severity level of the logger and/or handler to debug.</p>
</section>
<section id="logging-to-multiple-destinations" class="level2">
<h2 class="anchored" data-anchor-id="logging-to-multiple-destinations">Logging to multiple destinations<a href="https://docs.python.org/3/howto/logging-cookbook.html#logging-to-multiple-destinations" title="Link to this heading">¶</a></h2>
<p>Let’s say you want to log to console and file with different message formats and in differing circumstances. Say you want to log messages with levels of DEBUG and higher to file, and those messages at level INFO and higher to the console. Let’s also assume that the file should contain timestamps, but the console messages should not. Here’s how you can achieve this:</p>
<pre><code>import logging

# set up logging to file - see previous section for more details
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                    datefmt='%m-%d %H:%M',
                    filename='/tmp/myapp.log',
                    filemode='w')
# define a Handler which writes INFO messages or higher to the sys.stderr
console = logging.StreamHandler()
console.setLevel(logging.INFO)
# set a format which is simpler for console use
formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
# tell the handler to use this format
console.setFormatter(formatter)
# add the handler to the root logger
logging.getLogger('').addHandler(console)

# Now, we can log to the root logger, or any other logger. First the root...
logging.info('Jackdaws love my big sphinx of quartz.')

# Now, define a couple of other loggers which might represent areas in your
# application:

logger1 = logging.getLogger('myapp.area1')
logger2 = logging.getLogger('myapp.area2')

logger1.debug('Quick zephyrs blow, vexing daft Jim.')
logger1.info('How quickly daft jumping zebras vex.')
logger2.warning('Jail zesty vixen who grabbed pay from quack.')
logger2.error('The five boxing wizards jump quickly.')
</code></pre>
<p>When you run this, on the console you will see</p>
<pre><code>root        : INFO     Jackdaws love my big sphinx of quartz.
myapp.area1 : INFO     How quickly daft jumping zebras vex.
myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.
myapp.area2 : ERROR    The five boxing wizards jump quickly.
</code></pre>
<p>and in the file you will see something like</p>
<pre><code>10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.
10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.
10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.
10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from quack.
10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly.
</code></pre>
<p>As you can see, the DEBUG message only shows up in the file. The other messages are sent to both destinations.</p>
<p>This example uses console and file handlers, but you can use any number and combination of handlers you choose.</p>
<p>Note that the above choice of log filename <code>/tmp/myapp.log</code> implies use of a standard location for temporary files on POSIX systems. On Windows, you may need to choose a different directory name for the log - just ensure that the directory exists and that you have the permissions to create and update files in it.</p>
</section>
<section id="custom-handling-of-levels" class="level2">
<h2 class="anchored" data-anchor-id="custom-handling-of-levels">Custom handling of levels<a href="https://docs.python.org/3/howto/logging-cookbook.html#custom-handling-of-levels" title="Link to this heading">¶</a></h2>
<p>Sometimes, you might want to do something slightly different from the standard handling of levels in handlers, where all levels above a threshold get processed by a handler. To do this, you need to use filters. Let’s look at a scenario where you want to arrange things as follows:</p>
<ul>
<li><p>Send messages of severity <code>INFO</code> and <code>WARNING</code> to <code>sys.stdout</code></p></li>
<li><p>Send messages of severity <code>ERROR</code> and above to <code>sys.stderr</code></p></li>
<li><p>Send messages of severity <code>DEBUG</code> and above to file <code>app.log</code></p></li>
</ul>
<p>Suppose you configure logging with the following JSON:</p>
<pre><code>{
    "version": 1,
    "disable_existing_loggers": false,
    "formatters": {
        "simple": {
            "format": "%(levelname)-8s - %(message)s"
        }
    },
    "handlers": {
        "stdout": {
            "class": "logging.StreamHandler",
            "level": "INFO",
            "formatter": "simple",
            "stream": "ext://sys.stdout"
        },
        "stderr": {
            "class": "logging.StreamHandler",
            "level": "ERROR",
            "formatter": "simple",
            "stream": "ext://sys.stderr"
        },
        "file": {
            "class": "logging.FileHandler",
            "formatter": "simple",
            "filename": "app.log",
            "mode": "w"
        }
    },
    "root": {
        "level": "DEBUG",
        "handlers": [
            "stderr",
            "stdout",
            "file"
        ]
    }
}
</code></pre>
<p>This configuration does <em>almost</em> what we want, except that <code>sys.stdout</code> would show messages of severity <code>ERROR</code> and only events of this severity and higher will be tracked as well as <code>INFO</code> and <code>WARNING</code> messages. To prevent this, we can set up a filter which excludes those messages and add it to the relevant handler. This can be configured by adding a <code>filters</code> section parallel to <code>formatters</code> and <code>handlers</code>:</p>
<pre><code>{
    "filters": {
        "warnings_and_below": {
            "()" : "__main__.filter_maker",
            "level": "WARNING"
        }
    }
}
</code></pre>
<p>and changing the section on the <code>stdout</code> handler to add it:</p>
<pre><code>{
    "stdout": {
        "class": "logging.StreamHandler",
        "level": "INFO",
        "formatter": "simple",
        "stream": "ext://sys.stdout",
        "filters": ["warnings_and_below"]
    }
}
</code></pre>
<p>A filter is just a function, so we can define the <code>filter_maker</code> (a factory function) as follows:</p>
<pre><code>def filter_maker(level):
    level = getattr(logging, level)

    def filter(record):
        return record.levelno &lt;= level

    return filter
</code></pre>
<p>This converts the string argument passed in to a numeric level, and returns a function which only returns <code>True</code> if the level of the passed in record is at or below the specified level. Note that in this example I have defined the <code>filter_maker</code> in a test script <code>main.py</code> that I run from the command line, so its module will be <code>__main__</code> - hence the <code>__main__.filter_maker</code> in the filter configuration. You will need to change that if you define it in a different module.</p>
<p>With the filter added, we can run <code>main.py</code>, which in full is:</p>
<pre><code>import json
import logging
import logging.config

CONFIG = '''
{
    "version": 1,
    "disable_existing_loggers": false,
    "formatters": {
        "simple": {
            "format": "%(levelname)-8s - %(message)s"
        }
    },
    "filters": {
        "warnings_and_below": {
            "()" : "__main__.filter_maker",
            "level": "WARNING"
        }
    },
    "handlers": {
        "stdout": {
            "class": "logging.StreamHandler",
            "level": "INFO",
            "formatter": "simple",
            "stream": "ext://sys.stdout",
            "filters": ["warnings_and_below"]
        },
        "stderr": {
            "class": "logging.StreamHandler",
            "level": "ERROR",
            "formatter": "simple",
            "stream": "ext://sys.stderr"
        },
        "file": {
            "class": "logging.FileHandler",
            "formatter": "simple",
            "filename": "app.log",
            "mode": "w"
        }
    },
    "root": {
        "level": "DEBUG",
        "handlers": [
            "stderr",
            "stdout",
            "file"
        ]
    }
}
'''

def filter_maker(level):
    level = getattr(logging, level)

    def filter(record):
        return record.levelno &lt;= level

    return filter

logging.config.dictConfig(json.loads(CONFIG))
logging.debug('A DEBUG message')
logging.info('An INFO message')
logging.warning('A WARNING message')
logging.error('An ERROR message')
logging.critical('A CRITICAL message')
</code></pre>
<p>And after running it like this:</p>
<pre><code>python main.py 2&gt;stderr.log &gt;stdout.log
</code></pre>
<p>We can see the results are as expected:</p>
<pre><code>$ more *.log
::::::::::::::
app.log
::::::::::::::
DEBUG    - A DEBUG message
INFO     - An INFO message
WARNING  - A WARNING message
ERROR    - An ERROR message
CRITICAL - A CRITICAL message
::::::::::::::
stderr.log
::::::::::::::
ERROR    - An ERROR message
CRITICAL - A CRITICAL message
::::::::::::::
stdout.log
::::::::::::::
INFO     - An INFO message
WARNING  - A WARNING message
</code></pre>
</section>
<section id="configuration-server-example" class="level2">
<h2 class="anchored" data-anchor-id="configuration-server-example">Configuration server example<a href="https://docs.python.org/3/howto/logging-cookbook.html#configuration-server-example" title="Link to this heading">¶</a></h2>
<p>Here is an example of a module using the logging configuration server:</p>
<pre><code>import logging
import logging.config
import time
import os

# read initial config file
logging.config.fileConfig('logging.conf')

# create and start listener on port 9999
t = logging.config.listen(9999)
t.start()

logger = logging.getLogger('simpleExample')

try:
    # loop through logging calls to see the difference
    # new configurations make, until Ctrl+C is pressed
    while True:
        logger.debug('debug message')
        logger.info('info message')
        logger.warning('warn message')
        logger.error('error message')
        logger.critical('critical message')
        time.sleep(5)
except KeyboardInterrupt:
    # cleanup
    logging.config.stopListening()
    t.join()
</code></pre>
<p>And here is a script that takes a filename and sends that file to the server, properly preceded with the binary-encoded length, as the new logging configuration:</p>
<pre><code>#!/usr/bin/env python
import socket, sys, struct

with open(sys.argv[1], 'rb') as f:
    data_to_send = f.read()

HOST = 'localhost'
PORT = 9999
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print('connecting...')
s.connect((HOST, PORT))
print('sending config...')
s.send(struct.pack('&gt;L', len(data_to_send)))
s.send(data_to_send)
s.close()
print('complete')
</code></pre>
</section>
<section id="dealing-with-handlers-that-block" class="level2">
<h2 class="anchored" data-anchor-id="dealing-with-handlers-that-block">Dealing with handlers that block<a href="https://docs.python.org/3/howto/logging-cookbook.html#dealing-with-handlers-that-block" title="Link to this heading">¶</a></h2>
<p>Sometimes you have to get your logging handlers to do their work without blocking the thread you’re logging from. This is common in web applications, though of course it also occurs in other scenarios.</p>
<p>A common culprit which demonstrates sluggish behaviour is the <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code>SMTPHandler</code></a>: sending emails can take a long time, for a number of reasons outside the developer’s control (for example, a poorly performing mail or network infrastructure). But almost any network-based handler can block: Even a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code>SocketHandler</code></a> operation may do a DNS query under the hood which is too slow (and this query can be deep in the socket library code, below the Python layer, and outside your control).</p>
<p>One solution is to use a two-part approach. For the first part, attach only a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code>QueueHandler</code></a> to those loggers which are accessed from performance-critical threads. They simply write to their queue, which can be sized to a large enough capacity or initialized with no upper bound to their size. The write to the queue will typically be accepted quickly, though you will probably need to catch the <a href="https://docs.python.org/3/library/queue.html#queue.Full" title="queue.Full"><code>queue.Full</code></a> exception as a precaution in your code. If you are a library developer who has performance-critical threads in their code, be sure to document this (together with a suggestion to attach only <code>QueueHandlers</code> to your loggers) for the benefit of other developers who will use your code.</p>
<p>The second part of the solution is <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>QueueListener</code></a>, which has been designed as the counterpart to <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code>QueueHandler</code></a>. A <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>QueueListener</code></a> is very simple: it’s passed a queue and some handlers, and it fires up an internal thread which listens to its queue for LogRecords sent from <code>QueueHandlers</code> (or any other source of <code>LogRecords</code>, for that matter). The <code>LogRecords</code> are removed from the queue and passed to the handlers for processing.</p>
<p>The advantage of having a separate <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>QueueListener</code></a> class is that you can use the same instance to service multiple <code>QueueHandlers</code>. This is more resource-friendly than, say, having threaded versions of the existing handler classes, which would eat up one thread per handler for no particular benefit.</p>
<p>An example of using these two classes follows (imports omitted):</p>
<pre><code>que = queue.Queue(-1)  # no limit on size
queue_handler = QueueHandler(que)
handler = logging.StreamHandler()
listener = QueueListener(que, handler)
root = logging.getLogger()
root.addHandler(queue_handler)
formatter = logging.Formatter('%(threadName)s: %(message)s')
handler.setFormatter(formatter)
listener.start()
# The log output will display the thread which generated
# the event (the main thread) rather than the internal
# thread which monitors the internal queue. This is what
# you want to happen.
root.warning('Look out!')
listener.stop()
</code></pre>
<p>which, when run, will produce:</p>
<p>Note</p>
<p>Although the earlier discussion wasn’t specifically talking about async code, but rather about slow logging handlers, it should be noted that when logging from async code, network and even file handlers could lead to problems (blocking the event loop) because some logging is done from <a href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code>asyncio</code></a> internals. It might be best, if any async code is used in an application, to use the above approach for logging, so that any blocking code runs only in the <code>QueueListener</code> thread.</p>
<p>Changed in version 3.5: Prior to Python 3.5, the <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>QueueListener</code></a> always passed every message received from the queue to every handler it was initialized with. (This was because it was assumed that level filtering was all done on the other side, where the queue is filled.) From 3.5 onwards, this behaviour can be changed by passing a keyword argument <code>respect_handler_level=True</code> to the listener’s constructor. When this is done, the listener compares the level of each message with the handler’s level, and only passes a message to a handler if it’s appropriate to do so.</p>
</section>
<section id="sending-and-receiving-logging-events-across-a-network" class="level2">
<h2 class="anchored" data-anchor-id="sending-and-receiving-logging-events-across-a-network">Sending and receiving logging events across a network<a href="https://docs.python.org/3/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network" title="Link to this heading">¶</a></h2>
<p>Let’s say you want to send logging events across a network, and handle them at the receiving end. A simple way of doing this is attaching a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code>SocketHandler</code></a> instance to the root logger at the sending end:</p>
<pre><code>import logging, logging.handlers

rootLogger = logging.getLogger('')
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler('localhost',
                    logging.handlers.DEFAULT_TCP_LOGGING_PORT)
# don't bother with a formatter, since a socket handler sends the event as
# an unformatted pickle
rootLogger.addHandler(socketHandler)

# Now, we can log to the root logger, or any other logger. First the root...
logging.info('Jackdaws love my big sphinx of quartz.')

# Now, define a couple of other loggers which might represent areas in your
# application:

logger1 = logging.getLogger('myapp.area1')
logger2 = logging.getLogger('myapp.area2')

logger1.debug('Quick zephyrs blow, vexing daft Jim.')
logger1.info('How quickly daft jumping zebras vex.')
logger2.warning('Jail zesty vixen who grabbed pay from quack.')
logger2.error('The five boxing wizards jump quickly.')
</code></pre>
<p>At the receiving end, you can set up a receiver using the <a href="https://docs.python.org/3/library/socketserver.html#module-socketserver" title="socketserver: A framework for network servers."><code>socketserver</code></a> module. Here is a basic working example:</p>
<pre><code>import pickle
import logging
import logging.handlers
import socketserver
import struct


class LogRecordStreamHandler(socketserver.StreamRequestHandler):
    """Handler for a streaming logging request.

    This basically logs the record using whatever logging policy is
    configured locally.
    """

    def handle(self):
        """
        Handle multiple requests - each expected to be a 4-byte length,
        followed by the LogRecord in pickle format. Logs the record
        according to whatever policy is configured locally.
        """
        while True:
            chunk = self.connection.recv(4)
            if len(chunk) &lt; 4:
                break
            slen = struct.unpack('&gt;L', chunk)[0]
            chunk = self.connection.recv(slen)
            while len(chunk) &lt; slen:
                chunk = chunk + self.connection.recv(slen - len(chunk))
            obj = self.unPickle(chunk)
            record = logging.makeLogRecord(obj)
            self.handleLogRecord(record)

    def unPickle(self, data):
        return pickle.loads(data)

    def handleLogRecord(self, record):
        # if a name is specified, we use the named logger rather than the one
        # implied by the record.
        if self.server.logname is not None:
            name = self.server.logname
        else:
            name = record.name
        logger = logging.getLogger(name)
        # N.B. EVERY record gets logged. This is because Logger.handle
        # is normally called AFTER logger-level filtering. If you want
        # to do filtering, do it at the client end to save wasting
        # cycles and network bandwidth!
        logger.handle(record)

class LogRecordSocketReceiver(socketserver.ThreadingTCPServer):
    """
    Simple TCP socket-based logging receiver suitable for testing.
    """

    allow_reuse_address = True

    def __init__(self, host='localhost',
                 port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,
                 handler=LogRecordStreamHandler):
        socketserver.ThreadingTCPServer.__init__(self, (host, port), handler)
        self.abort = 0
        self.timeout = 1
        self.logname = None

    def serve_until_stopped(self):
        import select
        abort = 0
        while not abort:
            rd, wr, ex = select.select([self.socket.fileno()],
                                       [], [],
                                       self.timeout)
            if rd:
                self.handle_request()
            abort = self.abort

def main():
    logging.basicConfig(
        format='%(relativeCreated)5d %(name)-15s %(levelname)-8s %(message)s')
    tcpserver = LogRecordSocketReceiver()
    print('About to start TCP server...')
    tcpserver.serve_until_stopped()

if __name__ == '__main__':
    main()
</code></pre>
<p>First run the server, and then the client. On the client side, nothing is printed on the console; on the server side, you should see something like:</p>
<pre><code>About to start TCP server...
   59 root            INFO     Jackdaws love my big sphinx of quartz.
   59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.
   69 myapp.area1     INFO     How quickly daft jumping zebras vex.
   69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.
   69 myapp.area2     ERROR    The five boxing wizards jump quickly.
</code></pre>
<p>Note that there are some security issues with pickle in some scenarios. If these affect you, you can use an alternative serialization scheme by overriding the <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler.makePickle" title="logging.handlers.SocketHandler.makePickle"><code>makePickle()</code></a> method and implementing your alternative there, as well as adapting the above script to use your alternative serialization.</p>
<section id="running-a-logging-socket-listener-in-production" class="level3">
<h3 class="anchored" data-anchor-id="running-a-logging-socket-listener-in-production">Running a logging socket listener in production<a href="https://docs.python.org/3/howto/logging-cookbook.html#running-a-logging-socket-listener-in-production" title="Link to this heading">¶</a></h3>
<p>To run a logging listener in production, you may need to use a process-management tool such as <a href="http://supervisord.org/">Supervisor</a>. <a href="https://gist.github.com/vsajip/4b227eeec43817465ca835ca66f75e2b">Here is a Gist</a> which provides the bare-bones files to run the above functionality using Supervisor. It consists of the following files:</p>
<div class="line-block"></div>
<p>File</p>
<p>|</p>
<p>Purpose</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><code>prepare.sh</code></p>
<p>|</p>
<p>A Bash script to prepare the environment for testing</p>
<p>| |</p>
<p><code>supervisor.conf</code></p>
<p>|</p>
<p>The Supervisor configuration file, which has entries for the listener and a multi-process web application</p>
<p>| |</p>
<p><code>ensure_app.sh</code></p>
<p>|</p>
<p>A Bash script to ensure that Supervisor is running with the above configuration</p>
<p>| |</p>
<p><code>log_listener.py</code></p>
<p>|</p>
<p>The socket listener program which receives log events and records them to a file</p>
<p>| |</p>
<p><code>main.py</code></p>
<p>|</p>
<p>A simple web application which performs logging via a socket connected to the listener</p>
<p>| |</p>
<p><code>webapp.json</code></p>
<p>|</p>
<p>A JSON configuration file for the web application</p>
<p>| |</p>
<p><code>client.py</code></p>
<p>|</p>
<p>A Python script to exercise the web application</p>
<p>|</p>
<p>The web application uses <a href="https://gunicorn.org/">Gunicorn</a>, which is a popular web application server that starts multiple worker processes to handle requests. This example setup shows how the workers can write to the same log file without conflicting with one another — they all go through the socket listener.</p>
<p>To test these files, do the following in a POSIX environment:</p>
<ol type="1">
<li><p>Download <a href="https://gist.github.com/vsajip/4b227eeec43817465ca835ca66f75e2b">the Gist</a> as a ZIP archive using the Download ZIP button.</p></li>
<li><p>Unzip the above files from the archive into a scratch directory.</p></li>
<li><p>In the scratch directory, run <code>bash prepare.sh</code> to get things ready. This creates a <code>run</code> subdirectory to contain Supervisor-related and log files, and a <code>venv</code> subdirectory to contain a virtual environment into which <code>bottle</code>, <code>gunicorn</code> and <code>supervisor</code> are installed.</p></li>
<li><p>Run <code>bash ensure_app.sh</code> to ensure that Supervisor is running with the above configuration.</p></li>
<li><p>Run <code>venv/bin/python client.py</code> to exercise the web application, which will lead to records being written to the log.</p></li>
<li><p>Inspect the log files in the <code>run</code> subdirectory. You should see the most recent log lines in files matching the pattern <code>app.log*</code>. They won’t be in any particular order, since they have been handled concurrently by different worker processes in a non-deterministic way.</p></li>
<li><p>You can shut down the listener and the web application by running <code>venv/bin/supervisorctl -c supervisor.conf shutdown</code>.</p></li>
</ol>
<p>You may need to tweak the configuration files in the unlikely event that the configured ports clash with something else in your test environment.</p>
</section>
</section>
<section id="adding-contextual-information-to-your-logging-output" class="level2">
<h2 class="anchored" data-anchor-id="adding-contextual-information-to-your-logging-output">Adding contextual information to your logging output<a href="https://docs.python.org/3/howto/logging-cookbook.html#adding-contextual-information-to-your-logging-output" title="Link to this heading">¶</a></h2>
<p>Sometimes you want logging output to contain contextual information in addition to the parameters passed to the logging call. For example, in a networked application, it may be desirable to log client-specific information in the log (e.g.&nbsp;remote client’s username, or IP address). Although you could use the <em>extra</em> parameter to achieve this, it’s not always convenient to pass the information in this way. While it might be tempting to create <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a> instances on a per-connection basis, this is not a good idea because these instances are not garbage collected. While this is not a problem in practice, when the number of <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a> instances is dependent on the level of granularity you want to use in logging an application, it could be hard to manage if the number of <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a> instances becomes effectively unbounded.</p>
<section id="using-loggeradapters-to-impart-contextual-information" class="level3">
<h3 class="anchored" data-anchor-id="using-loggeradapters-to-impart-contextual-information">Using LoggerAdapters to impart contextual information<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-loggeradapters-to-impart-contextual-information" title="Link to this heading">¶</a></h3>
<p>An easy way in which you can pass contextual information to be output along with logging event information is to use the <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a> class. This class is designed to look like a <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a>, so that you can call <a href="https://docs.python.org/3/library/logging.html#logging.debug" title="logging.debug"><code>debug()</code></a>, <a href="https://docs.python.org/3/library/logging.html#logging.info" title="logging.info"><code>info()</code></a>, <a href="https://docs.python.org/3/library/logging.html#logging.warning" title="logging.warning"><code>warning()</code></a>, <a href="https://docs.python.org/3/library/logging.html#logging.error" title="logging.error"><code>error()</code></a>, <a href="https://docs.python.org/3/library/logging.html#logging.exception" title="logging.exception"><code>exception()</code></a>, <a href="https://docs.python.org/3/library/logging.html#logging.critical" title="logging.critical"><code>critical()</code></a> and <a href="https://docs.python.org/3/library/logging.html#logging.log" title="logging.log"><code>log()</code></a>. These methods have the same signatures as their counterparts in <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a>, so you can use the two types of instances interchangeably.</p>
<p>When you create an instance of <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a>, you pass it a <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a> instance and a dict-like object which contains your contextual information. When you call one of the logging methods on an instance of <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a>, it delegates the call to the underlying instance of <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a> passed to its constructor, and arranges to pass the contextual information in the delegated call. Here’s a snippet from the code of <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a>:</p>
<pre><code>def debug(self, msg, /, *args, **kwargs):
    """
    Delegate a debug call to the underlying logger, after adding
    contextual information from this adapter instance.
    """
    msg, kwargs = self.process(msg, kwargs)
    self.logger.debug(msg, *args, **kwargs)
</code></pre>
<p>The <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter.process" title="logging.LoggerAdapter.process"><code>process()</code></a> method of <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a> is where the contextual information is added to the logging output. It’s passed the message and keyword arguments of the logging call, and it passes back (potentially) modified versions of these to use in the call to the underlying logger. The default implementation of this method leaves the message alone, but inserts an ‘extra’ key in the keyword argument whose value is the dict-like object passed to the constructor. Of course, if you had passed an ‘extra’ keyword argument in the call to the adapter, it will be silently overwritten.</p>
<p>The advantage of using ‘extra’ is that the values in the dict-like object are merged into the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> instance’s __dict__, allowing you to use customized strings with your <a href="https://docs.python.org/3/library/logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> instances which know about the keys of the dict-like object. If you need a different method, e.g.&nbsp;if you want to prepend or append the contextual information to the message string, you just need to subclass <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a> and override <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter.process" title="logging.LoggerAdapter.process"><code>process()</code></a> to do what you need. Here is a simple example:</p>
<pre><code>class CustomAdapter(logging.LoggerAdapter):
    """
    This example adapter expects the passed in dict-like object to have a
    'connid' key, whose value in brackets is prepended to the log message.
    """
    def process(self, msg, kwargs):
        return '[%s] %s' % (self.extra['connid'], msg), kwargs
</code></pre>
<p>which you can use like this:</p>
<pre><code>logger = logging.getLogger(__name__)
adapter = CustomAdapter(logger, {'connid': some_conn_id})
</code></pre>
<p>Then any events that you log to the adapter will have the value of <code>some_conn_id</code> prepended to the log messages.</p>
<section id="using-objects-other-than-dicts-to-pass-contextual-information" class="level4">
<h4 class="anchored" data-anchor-id="using-objects-other-than-dicts-to-pass-contextual-information">Using objects other than dicts to pass contextual information<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-objects-other-than-dicts-to-pass-contextual-information" title="Link to this heading">¶</a></h4>
<p>You don’t need to pass an actual dict to a <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a> - you could pass an instance of a class which implements <code>__getitem__</code> and <code>__iter__</code> so that it looks like a dict to logging. This would be useful if you want to generate values dynamically (whereas the values in a dict would be constant).</p>
</section>
</section>
<section id="using-filters-to-impart-contextual-information" class="level3">
<h3 class="anchored" data-anchor-id="using-filters-to-impart-contextual-information">Using Filters to impart contextual information<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-filters-to-impart-contextual-information" title="Link to this heading">¶</a></h3>
<p>You can also add contextual information to log output using a user-defined <a href="https://docs.python.org/3/library/logging.html#logging.Filter" title="logging.Filter"><code>Filter</code></a>. <code>Filter</code> instances are allowed to modify the <code>LogRecords</code> passed to them, including adding additional attributes which can then be output using a suitable format string, or if needed a custom <a href="https://docs.python.org/3/library/logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a>.</p>
<p>For example in a web application, the request being processed (or at least, the interesting parts of it) can be stored in a threadlocal (<a href="https://docs.python.org/3/library/threading.html#threading.local" title="threading.local"><code>threading.local</code></a>) variable, and then accessed from a <code>Filter</code> to add, say, information from the request - say, the remote IP address and remote user’s username - to the <code>LogRecord</code>, using the attribute names ‘ip’ and ‘user’ as in the <code>LoggerAdapter</code> example above. In that case, the same format string can be used to get similar output to that shown above. Here’s an example script:</p>
<pre><code>import logging
from random import choice

class ContextFilter(logging.Filter):
    """
    This is a filter which injects contextual information into the log.

    Rather than use actual contextual information, we just use random
    data in this demo.
    """

    USERS = ['jim', 'fred', 'sheila']
    IPS = ['123.231.231.123', '127.0.0.1', '192.168.0.1']

    def filter(self, record):

        record.ip = choice(ContextFilter.IPS)
        record.user = choice(ContextFilter.USERS)
        return True

if __name__ == '__main__':
    levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL)
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)-15s %(name)-5s %(levelname)-8s IP: %(ip)-15s User: %(user)-8s %(message)s')
    a1 = logging.getLogger('a.b.c')
    a2 = logging.getLogger('d.e.f')

    f = ContextFilter()
    a1.addFilter(f)
    a2.addFilter(f)
    a1.debug('A debug message')
    a1.info('An info message with %s', 'some parameters')
    for x in range(10):
        lvl = choice(levels)
        lvlname = logging.getLevelName(lvl)
        a2.log(lvl, 'A message at %s level with %d %s', lvlname, 2, 'parameters')
</code></pre>
<p>which, when run, produces something like:</p>
<pre><code>2010-09-06 22:38:15,292 a.b.c DEBUG    IP: 123.231.231.123 User: fred     A debug message
2010-09-06 22:38:15,300 a.b.c INFO     IP: 192.168.0.1     User: sheila   An info message with some parameters
2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A message at CRITICAL level with 2 parameters
2010-09-06 22:38:15,300 d.e.f ERROR    IP: 127.0.0.1       User: jim      A message at ERROR level with 2 parameters
2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 127.0.0.1       User: sheila   A message at DEBUG level with 2 parameters
2010-09-06 22:38:15,300 d.e.f ERROR    IP: 123.231.231.123 User: fred     A message at ERROR level with 2 parameters
2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 192.168.0.1     User: jim      A message at CRITICAL level with 2 parameters
2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A message at CRITICAL level with 2 parameters
2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 192.168.0.1     User: jim      A message at DEBUG level with 2 parameters
2010-09-06 22:38:15,301 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A message at ERROR level with 2 parameters
2010-09-06 22:38:15,301 d.e.f DEBUG    IP: 123.231.231.123 User: fred     A message at DEBUG level with 2 parameters
2010-09-06 22:38:15,301 d.e.f INFO     IP: 123.231.231.123 User: fred     A message at INFO level with 2 parameters
</code></pre>
</section>
</section>
<section id="use-of-contextvars" class="level2">
<h2 class="anchored" data-anchor-id="use-of-contextvars">Use of <code>contextvars</code><a href="https://docs.python.org/3/howto/logging-cookbook.html#use-of-contextvars" title="Link to this heading">¶</a></h2>
<p>Since Python 3.7, the <a href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code>contextvars</code></a> module has provided context-local storage which works for both <a href="https://docs.python.org/3/library/threading.html#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> and <a href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code>asyncio</code></a> processing needs. This type of storage may thus be generally preferable to thread-locals. The following example shows how, in a multi-threaded environment, logs can populated with contextual information such as, for example, request attributes handled by web applications.</p>
<p>For the purposes of illustration, say that you have different web applications, each independent of the other but running in the same Python process and using a library common to them. How can each of these applications have their own log, where all logging messages from the library (and other request processing code) are directed to the appropriate application’s log file, while including in the log additional contextual information such as client IP, HTTP request method and client username?</p>
<p>Let’s assume that the library can be simulated by the following code:</p>
<pre><code># webapplib.py
import logging
import time

logger = logging.getLogger(__name__)

def useful():
    # Just a representative event logged from the library
    logger.debug('Hello from webapplib!')
    # Just sleep for a bit so other threads get to run
    time.sleep(0.01)
</code></pre>
<p>We can simulate the multiple web applications by means of two simple classes, <code>Request</code> and <code>WebApp</code>. These simulate how real threaded web applications work - each request is handled by a thread:</p>
<pre><code># main.py
import argparse
from contextvars import ContextVar
import logging
import os
from random import choice
import threading
import webapplib

logger = logging.getLogger(__name__)
root = logging.getLogger()
root.setLevel(logging.DEBUG)

class Request:
    """
    A simple dummy request class which just holds dummy HTTP request method,
    client IP address and client username
    """
    def __init__(self, method, ip, user):
        self.method = method
        self.ip = ip
        self.user = user

# A dummy set of requests which will be used in the simulation - we'll just pick
# from this list randomly. Note that all GET requests are from 192.168.2.XXX
# addresses, whereas POST requests are from 192.16.3.XXX addresses. Three users
# are represented in the sample requests.

REQUESTS = [
    Request('GET', '192.168.2.20', 'jim'),
    Request('POST', '192.168.3.20', 'fred'),
    Request('GET', '192.168.2.21', 'sheila'),
    Request('POST', '192.168.3.21', 'jim'),
    Request('GET', '192.168.2.22', 'fred'),
    Request('POST', '192.168.3.22', 'sheila'),
]

# Note that the format string includes references to request context information
# such as HTTP method, client IP and username

formatter = logging.Formatter('%(threadName)-11s %(appName)s %(name)-9s %(user)-6s %(ip)s %(method)-4s %(message)s')

# Create our context variables. These will be filled at the start of request
# processing, and used in the logging that happens during that processing

ctx_request = ContextVar('request')
ctx_appname = ContextVar('appname')

class InjectingFilter(logging.Filter):
    """
    A filter which injects context-specific information into logs and ensures
    that only information for a specific webapp is included in its log
    """
    def __init__(self, app):
        self.app = app

    def filter(self, record):
        request = ctx_request.get()
        record.method = request.method
        record.ip = request.ip
        record.user = request.user
        record.appName = appName = ctx_appname.get()
        return appName == self.app.name

class WebApp:
    """
    A dummy web application class which has its own handler and filter for a
    webapp-specific log.
    """
    def __init__(self, name):
        self.name = name
        handler = logging.FileHandler(name + '.log', 'w')
        f = InjectingFilter(self)
        handler.setFormatter(formatter)
        handler.addFilter(f)
        root.addHandler(handler)
        self.num_requests = 0

    def process_request(self, request):
        """
        This is the dummy method for processing a request. It's called on a
        different thread for every request. We store the context information into
        the context vars before doing anything else.
        """
        ctx_request.set(request)
        ctx_appname.set(self.name)
        self.num_requests += 1
        logger.debug('Request processing started')
        webapplib.useful()
        logger.debug('Request processing finished')

def main():
    fn = os.path.splitext(os.path.basename(__file__))[0]
    adhf = argparse.ArgumentDefaultsHelpFormatter
    ap = argparse.ArgumentParser(formatter_class=adhf, prog=fn,
                                 description='Simulate a couple of web '
                                             'applications handling some '
                                             'requests, showing how request '
                                             'context can be used to '
                                             'populate logs')
    aa = ap.add_argument
    aa('--count', '-c', type=int, default=100, help='How many requests to simulate')
    options = ap.parse_args()

    # Create the dummy webapps and put them in a list which we can use to select
    # from randomly
    app1 = WebApp('app1')
    app2 = WebApp('app2')
    apps = [app1, app2]
    threads = []
    # Add a common handler which will capture all events
    handler = logging.FileHandler('app.log', 'w')
    handler.setFormatter(formatter)
    root.addHandler(handler)

    # Generate calls to process requests
    for i in range(options.count):
        try:
            # Pick an app at random and a request for it to process
            app = choice(apps)
            request = choice(REQUESTS)
            # Process the request in its own thread
            t = threading.Thread(target=app.process_request, args=(request,))
            threads.append(t)
            t.start()
        except KeyboardInterrupt:
            break

    # Wait for the threads to terminate
    for t in threads:
        t.join()

    for app in apps:
        print('%s processed %s requests' % (app.name, app.num_requests))

if __name__ == '__main__':
    main()
</code></pre>
<p>If you run the above, you should find that roughly half the requests go into <code>app1.log</code> and the rest into <code>app2.log</code>, and the all the requests are logged to <code>app.log</code>. Each webapp-specific log will contain only log entries for only that webapp, and the request information will be displayed consistently in the log (i.e.&nbsp;the information in each dummy request will always appear together in a log line). This is illustrated by the following shell output:</p>
<pre><code>~/logging-contextual-webapp$ python main.py
app1 processed 51 requests
app2 processed 49 requests
~/logging-contextual-webapp$ wc -l *.log
  153 app1.log
  147 app2.log
  300 app.log
  600 total
~/logging-contextual-webapp$ head -3 app1.log
Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started
Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello from webapplib!
Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started
~/logging-contextual-webapp$ head -3 app2.log
Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request processing started
Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello from webapplib!
Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request processing started
~/logging-contextual-webapp$ head app.log
Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request processing started
Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello from webapplib!
Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request processing started
Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started
Thread-2 (process_request) app2 webapplib jim    192.168.2.20 GET  Hello from webapplib!
Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello from webapplib!
Thread-4 (process_request) app2 __main__  fred   192.168.2.22 GET  Request processing started
Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started
Thread-4 (process_request) app2 webapplib fred   192.168.2.22 GET  Hello from webapplib!
Thread-6 (process_request) app1 __main__  jim    192.168.3.21 POST Request processing started
~/logging-contextual-webapp$ grep app1 app1.log | wc -l
153
~/logging-contextual-webapp$ grep app2 app2.log | wc -l
147
~/logging-contextual-webapp$ grep app1 app.log | wc -l
153
~/logging-contextual-webapp$ grep app2 app.log | wc -l
147
</code></pre>
</section>
<section id="imparting-contextual-information-in-handlers" class="level2">
<h2 class="anchored" data-anchor-id="imparting-contextual-information-in-handlers">Imparting contextual information in handlers<a href="https://docs.python.org/3/howto/logging-cookbook.html#imparting-contextual-information-in-handlers" title="Link to this heading">¶</a></h2>
<p>Each <a href="https://docs.python.org/3/library/logging.html#logging.Handler" title="logging.Handler"><code>Handler</code></a> has its own chain of filters. If you want to add contextual information to a <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> without leaking it to other handlers, you can use a filter that returns a new <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> instead of modifying it in-place, as shown in the following script:</p>
<pre><code>import copy
import logging

def filter(record: logging.LogRecord):
    record = copy.copy(record)
    record.user = 'jim'
    return record

if __name__ == '__main__':
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(message)s from %(user)-8s')
    handler.setFormatter(formatter)
    handler.addFilter(filter)
    logger.addHandler(handler)

    logger.info('A log message')
</code></pre>
</section>
<section id="logging-to-a-single-file-from-multiple-processes" class="level2">
<h2 class="anchored" data-anchor-id="logging-to-a-single-file-from-multiple-processes">Logging to a single file from multiple processes<a href="https://docs.python.org/3/howto/logging-cookbook.html#logging-to-a-single-file-from-multiple-processes" title="Link to this heading">¶</a></h2>
<p>Although logging is thread-safe, and logging to a single file from multiple threads in a single process <em>is</em> supported, logging to a single file from <em>multiple processes</em> is <em>not</em> supported, because there is no standard way to serialize access to a single file across multiple processes in Python. If you need to log to a single file from multiple processes, one way of doing this is to have all the processes log to a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code>SocketHandler</code></a>, and have a separate process which implements a socket server which reads from the socket and logs to file. (If you prefer, you can dedicate one thread in one of the existing processes to perform this function.) <a href="https://docs.python.org/3/howto/logging-cookbook.html#network-logging">This section</a> documents this approach in more detail and includes a working socket receiver which can be used as a starting point for you to adapt in your own applications.</p>
<p>You could also write your own handler which uses the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Lock" title="multiprocessing.Lock"><code>Lock</code></a> class from the <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a> module to serialize access to the file from your processes. The stdlib <a href="https://docs.python.org/3/library/logging.handlers.html#logging.FileHandler" title="logging.FileHandler"><code>FileHandler</code></a> and subclasses do not make use of <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a>.</p>
<p>Alternatively, you can use a <code>Queue</code> and a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code>QueueHandler</code></a> to send all logging events to one of the processes in your multi-process application. The following example script demonstrates how you can do this; in the example a separate listener process listens for events sent by other processes and logs them according to its own logging configuration. Although the example only demonstrates one way of doing it (for example, you may want to use a listener thread rather than a separate listener process – the implementation would be analogous) it does allow for completely different logging configurations for the listener and the other processes in your application, and can be used as the basis for code meeting your own specific requirements:</p>
<pre><code># You'll need these imports in your own code
import logging
import logging.handlers
import multiprocessing

# Next two import lines for this demo only
from random import choice, random
import time

#
# Because you'll want to define the logging configurations for listener and workers, the
# listener and worker process functions take a configurer parameter which is a callable
# for configuring logging for that process. These functions are also passed the queue,
# which they use for communication.
#
# In practice, you can configure the listener however you want, but note that in this
# simple example, the listener does not apply level or filter logic to received records.
# In practice, you would probably want to do this logic in the worker processes, to avoid
# sending events which would be filtered out between processes.
#
# The size of the rotated files is made small so you can see the results easily.
def listener_configurer():
    root = logging.getLogger()
    h = logging.handlers.RotatingFileHandler('mptest.log', 'a', 300, 10)
    f = logging.Formatter('%(asctime)s %(processName)-10s %(name)s %(levelname)-8s %(message)s')
    h.setFormatter(f)
    root.addHandler(h)

# This is the listener process top-level loop: wait for logging events
# (LogRecords)on the queue and handle them, quit when you get a None for a
# LogRecord.
def listener_process(queue, configurer):
    configurer()
    while True:
        try:
            record = queue.get()
            if record is None:  # We send this as a sentinel to tell the listener to quit.
                break
            logger = logging.getLogger(record.name)
            logger.handle(record)  # No level or filter logic applied - just do it!
        except Exception:
            import sys, traceback
            print('Whoops! Problem:', file=sys.stderr)
            traceback.print_exc(file=sys.stderr)

# Arrays used for random selections in this demo

LEVELS = [logging.DEBUG, logging.INFO, logging.WARNING,
          logging.ERROR, logging.CRITICAL]

LOGGERS = ['a.b.c', 'd.e.f']

MESSAGES = [
    'Random message #1',
    'Random message #2',
    'Random message #3',
]

# The worker configuration is done at the start of the worker process run.
# Note that on Windows you can't rely on fork semantics, so each process
# will run the logging configuration code when it starts.
def worker_configurer(queue):
    h = logging.handlers.QueueHandler(queue)  # Just the one handler needed
    root = logging.getLogger()
    root.addHandler(h)
    # send all messages, for demo; no other level or filter logic applied.
    root.setLevel(logging.DEBUG)

# This is the worker process top-level loop, which just logs ten events with
# random intervening delays before terminating.
# The print messages are just so you know it's doing something!
def worker_process(queue, configurer):
    configurer(queue)
    name = multiprocessing.current_process().name
    print('Worker started: %s' % name)
    for i in range(10):
        time.sleep(random())
        logger = logging.getLogger(choice(LOGGERS))
        level = choice(LEVELS)
        message = choice(MESSAGES)
        logger.log(level, message)
    print('Worker finished: %s' % name)

# Here's where the demo gets orchestrated. Create the queue, create and start
# the listener, create ten workers and start them, wait for them to finish,
# then send a None to the queue to tell the listener to finish.
def main():
    queue = multiprocessing.Queue(-1)
    listener = multiprocessing.Process(target=listener_process,
                                       args=(queue, listener_configurer))
    listener.start()
    workers = []
    for i in range(10):
        worker = multiprocessing.Process(target=worker_process,
                                         args=(queue, worker_configurer))
        workers.append(worker)
        worker.start()
    for w in workers:
        w.join()
    queue.put_nowait(None)
    listener.join()

if __name__ == '__main__':
    main()
</code></pre>
<p>A variant of the above script keeps the logging in the main process, in a separate thread:</p>
<pre><code>import logging
import logging.config
import logging.handlers
from multiprocessing import Process, Queue
import random
import threading
import time

def logger_thread(q):
    while True:
        record = q.get()
        if record is None:
            break
        logger = logging.getLogger(record.name)
        logger.handle(record)


def worker_process(q):
    qh = logging.handlers.QueueHandler(q)
    root = logging.getLogger()
    root.setLevel(logging.DEBUG)
    root.addHandler(qh)
    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,
              logging.CRITICAL]
    loggers = ['foo', 'foo.bar', 'foo.bar.baz',
               'spam', 'spam.ham', 'spam.ham.eggs']
    for i in range(100):
        lvl = random.choice(levels)
        logger = logging.getLogger(random.choice(loggers))
        logger.log(lvl, 'Message no. %d', i)

if __name__ == '__main__':
    q = Queue()
    d = {
        'version': 1,
        'formatters': {
            'detailed': {
                'class': 'logging.Formatter',
                'format': '%(asctime)s %(name)-15s %(levelname)-8s %(processName)-10s %(message)s'
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'level': 'INFO',
            },
            'file': {
                'class': 'logging.FileHandler',
                'filename': 'mplog.log',
                'mode': 'w',
                'formatter': 'detailed',
            },
            'foofile': {
                'class': 'logging.FileHandler',
                'filename': 'mplog-foo.log',
                'mode': 'w',
                'formatter': 'detailed',
            },
            'errors': {
                'class': 'logging.FileHandler',
                'filename': 'mplog-errors.log',
                'mode': 'w',
                'level': 'ERROR',
                'formatter': 'detailed',
            },
        },
        'loggers': {
            'foo': {
                'handlers': ['foofile']
            }
        },
        'root': {
            'level': 'DEBUG',
            'handlers': ['console', 'file', 'errors']
        },
    }
    workers = []
    for i in range(5):
        wp = Process(target=worker_process, name='worker %d' % (i + 1), args=(q,))
        workers.append(wp)
        wp.start()
    logging.config.dictConfig(d)
    lp = threading.Thread(target=logger_thread, args=(q,))
    lp.start()
    # At this point, the main process could do some useful work of its own
    # Once it's done that, it can wait for the workers to terminate...
    for wp in workers:
        wp.join()
    # And now tell the logging thread to finish up, too
    q.put(None)
    lp.join()
</code></pre>
<p>This variant shows how you can e.g.&nbsp;apply configuration for particular loggers - e.g.&nbsp;the <code>foo</code> logger has a special handler which stores all events in the <code>foo</code> subsystem in a file <code>mplog-foo.log</code>. This will be used by the logging machinery in the main process (even though the logging events are generated in the worker processes) to direct the messages to the appropriate destinations.</p>
<section id="using-concurrent.futures.processpoolexecutor" class="level3">
<h3 class="anchored" data-anchor-id="using-concurrent.futures.processpoolexecutor">Using concurrent.futures.ProcessPoolExecutor<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-concurrent-futures-processpoolexecutor" title="Link to this heading">¶</a></h3>
<p>If you want to use <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code>concurrent.futures.ProcessPoolExecutor</code></a> to start your worker processes, you need to create the queue slightly differently. Instead of</p>
<pre><code>queue = multiprocessing.Queue(-1)
</code></pre>
<p>you should use</p>
<pre><code>queue = multiprocessing.Manager().Queue(-1)  # also works with the examples above
</code></pre>
<p>and you can then replace the worker creation from this:</p>
<pre><code>workers = []
for i in range(10):
    worker = multiprocessing.Process(target=worker_process,
                                     args=(queue, worker_configurer))
    workers.append(worker)
    worker.start()
for w in workers:
    w.join()
</code></pre>
<p>to this (remembering to first import <a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code>concurrent.futures</code></a>):</p>
<pre><code>with concurrent.futures.ProcessPoolExecutor(max_workers=10) as executor:
    for i in range(10):
        executor.submit(worker_process, queue, worker_configurer)
</code></pre>
</section>
<section id="deploying-web-applications-using-gunicorn-and-uwsgi" class="level3">
<h3 class="anchored" data-anchor-id="deploying-web-applications-using-gunicorn-and-uwsgi">Deploying Web applications using Gunicorn and uWSGI<a href="https://docs.python.org/3/howto/logging-cookbook.html#deploying-web-applications-using-gunicorn-and-uwsgi" title="Link to this heading">¶</a></h3>
<p>When deploying Web applications using <a href="https://gunicorn.org/">Gunicorn</a> or <a href="https://uwsgi-docs.readthedocs.io/en/latest/">uWSGI</a> (or similar), multiple worker processes are created to handle client requests. In such environments, avoid creating file-based handlers directly in your web application. Instead, use a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code>SocketHandler</code></a> to log from the web application to a listener in a separate process. This can be set up using a process management tool such as Supervisor - see <a href="https://docs.python.org/3/howto/logging-cookbook.html#running-a-logging-socket-listener-in-production">Running a logging socket listener in production</a> for more details.</p>
</section>
</section>
<section id="using-file-rotation" class="level2">
<h2 class="anchored" data-anchor-id="using-file-rotation">Using file rotation<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-file-rotation" title="Link to this heading">¶</a></h2>
<p>Sometimes you want to let a log file grow to a certain size, then open a new file and log to that. You may want to keep a certain number of these files, and when that many files have been created, rotate the files so that the number of files and the size of the files both remain bounded. For this usage pattern, the logging package provides a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code>RotatingFileHandler</code></a>:</p>
<pre><code>import glob
import logging
import logging.handlers

LOG_FILENAME = 'logging_rotatingfile_example.out'

# Set up a specific logger with our desired output level
my_logger = logging.getLogger('MyLogger')
my_logger.setLevel(logging.DEBUG)

# Add the log message handler to the logger
handler = logging.handlers.RotatingFileHandler(
              LOG_FILENAME, maxBytes=20, backupCount=5)

my_logger.addHandler(handler)

# Log some messages
for i in range(20):
    my_logger.debug('i = %d' % i)

# See what files are created
logfiles = glob.glob('%s*' % LOG_FILENAME)

for filename in logfiles:
    print(filename)
</code></pre>
<p>The result should be 6 separate files, each with part of the log history for the application:</p>
<pre><code>logging_rotatingfile_example.out
logging_rotatingfile_example.out.1
logging_rotatingfile_example.out.2
logging_rotatingfile_example.out.3
logging_rotatingfile_example.out.4
logging_rotatingfile_example.out.5
</code></pre>
<p>The most current file is always <code>logging_rotatingfile_example.out</code>, and each time it reaches the size limit it is renamed with the suffix <code>.1</code>. Each of the existing backup files is renamed to increment the suffix (<code>.1</code> becomes <code>.2</code>, etc.) and the <code>.6</code> file is erased.</p>
<p>Obviously this example sets the log length much too small as an extreme example. You would want to set <em>maxBytes</em> to an appropriate value.</p>
</section>
<section id="use-of-alternative-formatting-styles" class="level2">
<h2 class="anchored" data-anchor-id="use-of-alternative-formatting-styles">Use of alternative formatting styles<a href="https://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles" title="Link to this heading">¶</a></h2>
<p>When logging was added to the Python standard library, the only way of formatting messages with variable content was to use the %-formatting method. Since then, Python has gained two new formatting approaches: <a href="https://docs.python.org/3/library/string.html#string.Template" title="string.Template"><code>string.Template</code></a> (added in Python 2.4) and <a href="https://docs.python.org/3/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> (added in Python 2.6).</p>
<p>Logging (as of 3.2) provides improved support for these two additional formatting styles. The <a href="https://docs.python.org/3/library/logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> class been enhanced to take an additional, optional keyword parameter named <code>style</code>. This defaults to <code>'%'</code>, but other possible values are <code>'{'</code> and <code>'$'</code>, which correspond to the other two formatting styles. Backwards compatibility is maintained by default (as you would expect), but by explicitly specifying a style parameter, you get the ability to specify format strings which work with <a href="https://docs.python.org/3/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> or <a href="https://docs.python.org/3/library/string.html#string.Template" title="string.Template"><code>string.Template</code></a>. Here’s an example console session to show the possibilities:</p>
<p>&gt;&gt;&gt;</p>
<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; root = logging.getLogger()
&gt;&gt;&gt; root.setLevel(logging.DEBUG)
&gt;&gt;&gt; handler = logging.StreamHandler()
&gt;&gt;&gt; bf = logging.Formatter('{asctime} {name} {levelname:8s} {message}',
...                        style='{')
&gt;&gt;&gt; handler.setFormatter(bf)
&gt;&gt;&gt; root.addHandler(handler)
&gt;&gt;&gt; logger = logging.getLogger('foo.bar')
&gt;&gt;&gt; logger.debug('This is a DEBUG message')
2010-10-28 15:11:55,341 foo.bar DEBUG    This is a DEBUG message
&gt;&gt;&gt; logger.critical('This is a CRITICAL message')
2010-10-28 15:12:11,526 foo.bar CRITICAL This is a CRITICAL message
&gt;&gt;&gt; df = logging.Formatter('$asctime $name ${levelname} $message',
...                        style='$')
&gt;&gt;&gt; handler.setFormatter(df)
&gt;&gt;&gt; logger.debug('This is a DEBUG message')
2010-10-28 15:13:06,924 foo.bar DEBUG This is a DEBUG message
&gt;&gt;&gt; logger.critical('This is a CRITICAL message')
2010-10-28 15:13:11,494 foo.bar CRITICAL This is a CRITICAL message
&gt;&gt;&gt;
</code></pre>
<p>Note that the formatting of logging messages for final output to logs is completely independent of how an individual logging message is constructed. That can still use %-formatting, as shown here:</p>
<p>&gt;&gt;&gt;</p>
<pre><code>&gt;&gt;&gt; logger.error('This is an%s %s %s', 'other,', 'ERROR,', 'message')
2010-10-28 15:19:29,833 foo.bar ERROR This is another, ERROR, message
&gt;&gt;&gt;
</code></pre>
<p>Logging calls (<code>logger.debug()</code>, <code>logger.info()</code> etc.) only take positional parameters for the actual logging message itself, with keyword parameters used only for determining options for how to handle the actual logging call (e.g.&nbsp;the <code>exc_info</code> keyword parameter to indicate that traceback information should be logged, or the <code>extra</code> keyword parameter to indicate additional contextual information to be added to the log). So you cannot directly make logging calls using <a href="https://docs.python.org/3/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> or <a href="https://docs.python.org/3/library/string.html#string.Template" title="string.Template"><code>string.Template</code></a> syntax, because internally the logging package uses %-formatting to merge the format string and the variable arguments. There would be no changing this while preserving backward compatibility, since all logging calls which are out there in existing code will be using %-format strings.</p>
<p>There is, however, a way that you can use {}- and $- formatting to construct your individual log messages. Recall that for a message you can use an arbitrary object as a message format string, and that the logging package will call <code>str()</code> on that object to get the actual format string. Consider the following two classes:</p>
<pre><code>class BraceMessage:
    def __init__(self, fmt, /, *args, **kwargs):
        self.fmt = fmt
        self.args = args
        self.kwargs = kwargs

    def __str__(self):
        return self.fmt.format(*self.args, **self.kwargs)

class DollarMessage:
    def __init__(self, fmt, /, **kwargs):
        self.fmt = fmt
        self.kwargs = kwargs

    def __str__(self):
        from string import Template
        return Template(self.fmt).substitute(**self.kwargs)
</code></pre>
<p>Either of these can be used in place of a format string, to allow {}- or <span class="math inline">\(-formatting to be used to build the actual “message” part which appears in the formatted log output in place of “%(message)s” or “{message}” or “\)</span>message”. It’s a little unwieldy to use the class names whenever you want to log something, but it’s quite palatable if you use an alias such as __ (double underscore — not to be confused with _, the single underscore used as a synonym/alias for <a href="https://docs.python.org/3/library/gettext.html#gettext.gettext" title="gettext.gettext"><code>gettext.gettext()</code></a> or its brethren).</p>
<p>The above classes are not included in Python, though they’re easy enough to copy and paste into your own code. They can be used as follows (assuming that they’re declared in a module called <code>wherever</code>):</p>
<p>&gt;&gt;&gt;</p>
<pre><code>&gt;&gt;&gt; from wherever import BraceMessage as __
&gt;&gt;&gt; print(__('Message with {0} {name}', 2, name='placeholders'))
Message with 2 placeholders
&gt;&gt;&gt; class Point: pass
...
&gt;&gt;&gt; p = Point()
&gt;&gt;&gt; p.x = 0.5
&gt;&gt;&gt; p.y = 0.5
&gt;&gt;&gt; print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})',
...       point=p))
Message with coordinates: (0.50, 0.50)
&gt;&gt;&gt; from wherever import DollarMessage as __
&gt;&gt;&gt; print(__('Message with $num $what', num=2, what='placeholders'))
Message with 2 placeholders
&gt;&gt;&gt;
</code></pre>
<p>While the above examples use <code>print()</code> to show how the formatting works, you would of course use <code>logger.debug()</code> or similar to actually log using this approach.</p>
<p>One thing to note is that you pay no significant performance penalty with this approach: the actual formatting happens not when you make the logging call, but when (and if) the logged message is actually about to be output to a log by a handler. So the only slightly unusual thing which might trip you up is that the parentheses go around the format string and the arguments, not just the format string. That’s because the __ notation is just syntax sugar for a constructor call to one of the <code>_XXX_Message</code> classes.</p>
<p>If you prefer, you can use a <a href="https://docs.python.org/3/library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a> to achieve a similar effect to the above, as in the following example:</p>
<pre><code>import logging

class Message:
    def __init__(self, fmt, args):
        self.fmt = fmt
        self.args = args

    def __str__(self):
        return self.fmt.format(*self.args)

class StyleAdapter(logging.LoggerAdapter):
    def log(self, level, msg, /, *args, stacklevel=1, **kwargs):
        if self.isEnabledFor(level):
            msg, kwargs = self.process(msg, kwargs)
            self.logger.log(level, Message(msg, args), **kwargs,
                            stacklevel=stacklevel+1)

logger = StyleAdapter(logging.getLogger(__name__))

def main():
    logger.debug('Hello, {}', 'world!')

if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    main()
</code></pre>
<p>The above script should log the message <code>Hello, world!</code> when run with Python 3.8 or later.</p>
</section>
<section id="customizing-logrecord" class="level2">
<h2 class="anchored" data-anchor-id="customizing-logrecord">Customizing <code>LogRecord</code><a href="https://docs.python.org/3/howto/logging-cookbook.html#customizing-logrecord" title="Link to this heading">¶</a></h2>
<p>Every logging event is represented by a <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> instance. When an event is logged and not filtered out by a logger’s level, a <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> is created, populated with information about the event and then passed to the handlers for that logger (and its ancestors, up to and including the logger where further propagation up the hierarchy is disabled). Before Python 3.2, there were only two places where this creation was done:</p>
<ul>
<li><p><a href="https://docs.python.org/3/library/logging.html#logging.Logger.makeRecord" title="logging.Logger.makeRecord"><code>Logger.makeRecord()</code></a>, which is called in the normal process of logging an event. This invoked <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> directly to create an instance.</p></li>
<li><p><a href="https://docs.python.org/3/library/logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code>makeLogRecord()</code></a>, which is called with a dictionary containing attributes to be added to the LogRecord. This is typically invoked when a suitable dictionary has been received over the network (e.g.&nbsp;in pickle form via a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code>SocketHandler</code></a>, or in JSON form via an <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code>HTTPHandler</code></a>).</p></li>
</ul>
<p>This has usually meant that if you need to do anything special with a <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a>, you’ve had to do one of the following.</p>
<ul>
<li><p>Create your own <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a> subclass, which overrides <a href="https://docs.python.org/3/library/logging.html#logging.Logger.makeRecord" title="logging.Logger.makeRecord"><code>Logger.makeRecord()</code></a>, and set it using <a href="https://docs.python.org/3/library/logging.html#logging.setLoggerClass" title="logging.setLoggerClass"><code>setLoggerClass()</code></a> before any loggers that you care about are instantiated.</p></li>
<li><p>Add a <a href="https://docs.python.org/3/library/logging.html#logging.Filter" title="logging.Filter"><code>Filter</code></a> to a logger or handler, which does the necessary special manipulation you need when its <a href="https://docs.python.org/3/library/logging.html#logging.Filter.filter" title="logging.Filter.filter"><code>filter()</code></a> method is called.</p></li>
</ul>
<p>The first approach would be a little unwieldy in the scenario where (say) several different libraries wanted to do different things. Each would attempt to set its own <a href="https://docs.python.org/3/library/logging.html#logging.Logger" title="logging.Logger"><code>Logger</code></a> subclass, and the one which did this last would win.</p>
<p>The second approach works reasonably well for many cases, but does not allow you to e.g.&nbsp;use a specialized subclass of <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a>. Library developers can set a suitable filter on their loggers, but they would have to remember to do this every time they introduced a new logger (which they would do simply by adding new packages or modules and doing</p>
<pre><code>logger = logging.getLogger(__name__)
</code></pre>
<p>at module level). It’s probably one too many things to think about. Developers could also add the filter to a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.NullHandler" title="logging.NullHandler"><code>NullHandler</code></a> attached to their top-level logger, but this would not be invoked if an application developer attached a handler to a lower-level library logger — so output from that handler would not reflect the intentions of the library developer.</p>
<p>In Python 3.2 and later, <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> creation is done through a factory, which you can specify. The factory is just a callable you can set with <a href="https://docs.python.org/3/library/logging.html#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code>setLogRecordFactory()</code></a>, and interrogate with <a href="https://docs.python.org/3/library/logging.html#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code>getLogRecordFactory()</code></a>. The factory is invoked with the same signature as the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> constructor, as <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> is the default setting for the factory.</p>
<p>This approach allows a custom factory to control all aspects of LogRecord creation. For example, you could return a subclass, or just add some additional attributes to the record once created, using a pattern similar to this:</p>
<pre><code>old_factory = logging.getLogRecordFactory()

def record_factory(*args, **kwargs):
    record = old_factory(*args, **kwargs)
    record.custom_attribute = 0xdecafbad
    return record

logging.setLogRecordFactory(record_factory)
</code></pre>
<p>This pattern allows different libraries to chain factories together, and as long as they don’t overwrite each other’s attributes or unintentionally overwrite the attributes provided as standard, there should be no surprises. However, it should be borne in mind that each link in the chain adds run-time overhead to all logging operations, and the technique should only be used when the use of a <a href="https://docs.python.org/3/library/logging.html#logging.Filter" title="logging.Filter"><code>Filter</code></a> does not provide the desired result.</p>
</section>
<section id="subclassing-queuehandler-and-queuelistener--a-zeromq-example" class="level2">
<h2 class="anchored" data-anchor-id="subclassing-queuehandler-and-queuelistener--a-zeromq-example">Subclassing QueueHandler and QueueListener- a ZeroMQ example<a href="https://docs.python.org/3/howto/logging-cookbook.html#subclassing-queuehandler-and-queuelistener-a-zeromq-example" title="Link to this heading">¶</a></h2>
<section id="subclass-queuehandler" class="level3">
<h3 class="anchored" data-anchor-id="subclass-queuehandler">Subclass <code>QueueHandler</code><a href="https://docs.python.org/3/howto/logging-cookbook.html#subclass-queuehandler" title="Link to this heading">¶</a></h3>
<p>You can use a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code>QueueHandler</code></a> subclass to send messages to other kinds of queues, for example a ZeroMQ ‘publish’ socket. In the example below,the socket is created separately and passed to the handler (as its ‘queue’):</p>
<pre><code>import zmq   # using pyzmq, the Python binding for ZeroMQ
import json  # for serializing records portably

ctx = zmq.Context()
sock = zmq.Socket(ctx, zmq.PUB)  # or zmq.PUSH, or other suitable value
sock.bind('tcp://*:5556')        # or wherever

class ZeroMQSocketHandler(QueueHandler):
    def enqueue(self, record):
        self.queue.send_json(record.__dict__)


handler = ZeroMQSocketHandler(sock)
</code></pre>
<p>Of course there are other ways of organizing this, for example passing in the data needed by the handler to create the socket:</p>
<pre><code>class ZeroMQSocketHandler(QueueHandler):
    def __init__(self, uri, socktype=zmq.PUB, ctx=None):
        self.ctx = ctx or zmq.Context()
        socket = zmq.Socket(self.ctx, socktype)
        socket.bind(uri)
        super().__init__(socket)

    def enqueue(self, record):
        self.queue.send_json(record.__dict__)

    def close(self):
        self.queue.close()
</code></pre>
</section>
<section id="subclass-queuelistener" class="level3">
<h3 class="anchored" data-anchor-id="subclass-queuelistener">Subclass <code>QueueListener</code><a href="https://docs.python.org/3/howto/logging-cookbook.html#subclass-queuelistener" title="Link to this heading">¶</a></h3>
<p>You can also subclass <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code>QueueListener</code></a> to get messages from other kinds of queues, for example a ZeroMQ ‘subscribe’ socket. Here’s an example:</p>
<pre><code>class ZeroMQSocketListener(QueueListener):
    def __init__(self, uri, /, *handlers, **kwargs):
        self.ctx = kwargs.get('ctx') or zmq.Context()
        socket = zmq.Socket(self.ctx, zmq.SUB)
        socket.setsockopt_string(zmq.SUBSCRIBE, '')  # subscribe to everything
        socket.connect(uri)
        super().__init__(socket, *handlers, **kwargs)

    def dequeue(self):
        msg = self.queue.recv_json()
        return logging.makeLogRecord(msg)
</code></pre>
</section>
</section>
<section id="subclassing-queuehandler-and-queuelistener--a-pynng-example" class="level2">
<h2 class="anchored" data-anchor-id="subclassing-queuehandler-and-queuelistener--a-pynng-example">Subclassing QueueHandler and QueueListener- a <code>pynng</code> example<a href="https://docs.python.org/3/howto/logging-cookbook.html#subclassing-queuehandler-and-queuelistener-a-pynng-example" title="Link to this heading">¶</a></h2>
<p>In a similar way to the above section, we can implement a listener and handler using <a href="https://pypi.org/project/pynng/">pynng</a>, which is a Python binding to <a href="https://nng.nanomsg.org/">NNG</a>, billed as a spiritual successor to ZeroMQ. The following snippets illustrate – you can test them in an environment which has <code>pynng</code> installed. Just for variety, we present the listener first.</p>
<section id="subclass-queuelistener-1" class="level3">
<h3 class="anchored" data-anchor-id="subclass-queuelistener-1">Subclass <code>QueueListener</code><a href="https://docs.python.org/3/howto/logging-cookbook.html#id3" title="Link to this heading">¶</a></h3>
<pre><code># listener.py
import json
import logging
import logging.handlers

import pynng

DEFAULT_ADDR = "tcp://localhost:13232"

interrupted = False

class NNGSocketListener(logging.handlers.QueueListener):

    def __init__(self, uri, /, *handlers, **kwargs):
        # Have a timeout for interruptability, and open a
        # subscriber socket
        socket = pynng.Sub0(listen=uri, recv_timeout=500)
        # The b'' subscription matches all topics
        topics = kwargs.pop('topics', None) or b''
        socket.subscribe(topics)
        # We treat the socket as a queue
        super().__init__(socket, *handlers, **kwargs)

    def dequeue(self, block):
        data = None
        # Keep looping while not interrupted and no data received over the
        # socket
        while not interrupted:
            try:
                data = self.queue.recv(block=block)
                break
            except pynng.Timeout:
                pass
            except pynng.Closed:  # sometimes happens when you hit Ctrl-C
                break
        if data is None:
            return None
        # Get the logging event sent from a publisher
        event = json.loads(data.decode('utf-8'))
        return logging.makeLogRecord(event)

    def enqueue_sentinel(self):
        # Not used in this implementation, as the socket isn't really a
        # queue
        pass

logging.getLogger('pynng').propagate = False
listener = NNGSocketListener(DEFAULT_ADDR, logging.StreamHandler(), topics=b'')
listener.start()
print('Press Ctrl-C to stop.')
try:
    while True:
        pass
except KeyboardInterrupt:
    interrupted = True
finally:
    listener.stop()
</code></pre>
</section>
<section id="subclass-queuehandler-1" class="level3">
<h3 class="anchored" data-anchor-id="subclass-queuehandler-1">Subclass <code>QueueHandler</code><a href="https://docs.python.org/3/howto/logging-cookbook.html#id4" title="Link to this heading">¶</a></h3>
<pre><code># sender.py
import json
import logging
import logging.handlers
import time
import random

import pynng

DEFAULT_ADDR = "tcp://localhost:13232"

class NNGSocketHandler(logging.handlers.QueueHandler):

    def __init__(self, uri):
        socket = pynng.Pub0(dial=uri, send_timeout=500)
        super().__init__(socket)

    def enqueue(self, record):
        # Send the record as UTF-8 encoded JSON
        d = dict(record.__dict__)
        data = json.dumps(d)
        self.queue.send(data.encode('utf-8'))

    def close(self):
        self.queue.close()

logging.getLogger('pynng').propagate = False
handler = NNGSocketHandler(DEFAULT_ADDR)
# Make sure the process ID is in the output
logging.basicConfig(level=logging.DEBUG,
                    handlers=[logging.StreamHandler(), handler],
                    format='%(levelname)-8s %(name)10s %(process)6s %(message)s')
levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,
          logging.CRITICAL)
logger_names = ('myapp', 'myapp.lib1', 'myapp.lib2')
msgno = 1
while True:
    # Just randomly select some loggers and levels and log away
    level = random.choice(levels)
    logger = logging.getLogger(random.choice(logger_names))
    logger.log(level, 'Message no. %5d' % msgno)
    msgno += 1
    delay = random.random() * 2 + 0.5
    time.sleep(delay)
</code></pre>
<p>You can run the above two snippets in separate command shells. If we run the listener in one shell and run the sender in two separate shells, we should see something like the following. In the first sender shell:</p>
<pre><code>$ python sender.py
DEBUG         myapp    613 Message no.     1
WARNING  myapp.lib2    613 Message no.     2
CRITICAL myapp.lib2    613 Message no.     3
WARNING  myapp.lib2    613 Message no.     4
CRITICAL myapp.lib1    613 Message no.     5
DEBUG         myapp    613 Message no.     6
CRITICAL myapp.lib1    613 Message no.     7
INFO     myapp.lib1    613 Message no.     8
(and so on)
</code></pre>
<p>In the second sender shell:</p>
<pre><code>$ python sender.py
INFO     myapp.lib2    657 Message no.     1
CRITICAL myapp.lib2    657 Message no.     2
CRITICAL      myapp    657 Message no.     3
CRITICAL myapp.lib1    657 Message no.     4
INFO     myapp.lib1    657 Message no.     5
WARNING  myapp.lib2    657 Message no.     6
CRITICAL      myapp    657 Message no.     7
DEBUG    myapp.lib1    657 Message no.     8
(and so on)
</code></pre>
<p>In the listener shell:</p>
<pre><code>$ python listener.py
Press Ctrl-C to stop.
DEBUG         myapp    613 Message no.     1
WARNING  myapp.lib2    613 Message no.     2
INFO     myapp.lib2    657 Message no.     1
CRITICAL myapp.lib2    613 Message no.     3
CRITICAL myapp.lib2    657 Message no.     2
CRITICAL      myapp    657 Message no.     3
WARNING  myapp.lib2    613 Message no.     4
CRITICAL myapp.lib1    613 Message no.     5
CRITICAL myapp.lib1    657 Message no.     4
INFO     myapp.lib1    657 Message no.     5
DEBUG         myapp    613 Message no.     6
WARNING  myapp.lib2    657 Message no.     6
CRITICAL      myapp    657 Message no.     7
CRITICAL myapp.lib1    613 Message no.     7
INFO     myapp.lib1    613 Message no.     8
DEBUG    myapp.lib1    657 Message no.     8
(and so on)
</code></pre>
<p>As you can see, the logging from the two sender processes is interleaved in the listener’s output.</p>
</section>
</section>
<section id="an-example-dictionary-based-configuration" class="level2">
<h2 class="anchored" data-anchor-id="an-example-dictionary-based-configuration">An example dictionary-based configuration<a href="https://docs.python.org/3/howto/logging-cookbook.html#an-example-dictionary-based-configuration" title="Link to this heading">¶</a></h2>
<p>Below is an example of a logging configuration dictionary - it’s taken from the <a href="https://docs.djangoproject.com/en/stable/topics/logging/#configuring-logging">documentation on the Django project</a>. This dictionary is passed to <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> to put the configuration into effect:</p>
<pre><code>LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'filters': {
        'special': {
            '()': 'project.logging.SpecialFilter',
            'foo': 'bar',
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler',
            'filters': ['special']
        }
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'propagate': True,
        },
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': False,
        },
        'myproject.custom': {
            'handlers': ['console', 'mail_admins'],
            'level': 'INFO',
            'filters': ['special']
        }
    }
}
</code></pre>
<p>For more information about this configuration, you can see the <a href="https://docs.djangoproject.com/en/stable/topics/logging/#configuring-logging">relevant section</a> of the Django documentation.</p>
</section>
<section id="using-a-rotator-and-namer-to-customize-log-rotation-processing" class="level2">
<h2 class="anchored" data-anchor-id="using-a-rotator-and-namer-to-customize-log-rotation-processing">Using a rotator and namer to customize log rotation processing<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-a-rotator-and-namer-to-customize-log-rotation-processing" title="Link to this heading">¶</a></h2>
<p>An example of how you can define a namer and rotator is given in the following runnable script, which shows gzip compression of the log file:</p>
<pre><code>import gzip
import logging
import logging.handlers
import os
import shutil

def namer(name):
    return name + ".gz"

def rotator(source, dest):
    with open(source, 'rb') as f_in:
        with gzip.open(dest, 'wb') as f_out:
            shutil.copyfileobj(f_in, f_out)
    os.remove(source)


rh = logging.handlers.RotatingFileHandler('rotated.log', maxBytes=128, backupCount=5)
rh.rotator = rotator
rh.namer = namer

root = logging.getLogger()
root.setLevel(logging.INFO)
root.addHandler(rh)
f = logging.Formatter('%(asctime)s %(message)s')
rh.setFormatter(f)
for i in range(1000):
    root.info(f'Message no. {i + 1}')
</code></pre>
<p>After running this, you will see six new files, five of which are compressed:</p>
<pre><code>$ ls rotated.log*
rotated.log       rotated.log.2.gz  rotated.log.4.gz
rotated.log.1.gz  rotated.log.3.gz  rotated.log.5.gz
$ zcat rotated.log.1.gz
2023-01-20 02:28:17,767 Message no. 996
2023-01-20 02:28:17,767 Message no. 997
2023-01-20 02:28:17,767 Message no. 998
</code></pre>
</section>
<section id="a-more-elaborate-multiprocessing-example" class="level2">
<h2 class="anchored" data-anchor-id="a-more-elaborate-multiprocessing-example">A more elaborate multiprocessing example<a href="https://docs.python.org/3/howto/logging-cookbook.html#a-more-elaborate-multiprocessing-example" title="Link to this heading">¶</a></h2>
<p>The following working example shows how logging can be used with multiprocessing using configuration files. The configurations are fairly simple, but serve to illustrate how more complex ones could be implemented in a real multiprocessing scenario.</p>
<p>In the example, the main process spawns a listener process and some worker processes. Each of the main process, the listener and the workers have three separate configurations (the workers all share the same configuration). We can see logging in the main process, how the workers log to a QueueHandler and how the listener implements a QueueListener and a more complex logging configuration, and arranges to dispatch events received via the queue to the handlers specified in the configuration. Note that these configurations are purely illustrative, but you should be able to adapt this example to your own scenario.</p>
<p>Here’s the script - the docstrings and the comments hopefully explain how it works:</p>
<pre><code>import logging
import logging.config
import logging.handlers
from multiprocessing import Process, Queue, Event, current_process
import os
import random
import time

class MyHandler:
    """
    A simple handler for logging events. It runs in the listener process and
    dispatches events to loggers based on the name in the received record,
    which then get dispatched, by the logging system, to the handlers
    configured for those loggers.
    """

    def handle(self, record):
        if record.name == "root":
            logger = logging.getLogger()
        else:
            logger = logging.getLogger(record.name)

        if logger.isEnabledFor(record.levelno):
            # The process name is transformed just to show that it's the listener
            # doing the logging to files and console
            record.processName = '%s (for %s)' % (current_process().name, record.processName)
            logger.handle(record)

def listener_process(q, stop_event, config):
    """
    This could be done in the main process, but is just done in a separate
    process for illustrative purposes.

    This initialises logging according to the specified configuration,
    starts the listener and waits for the main process to signal completion
    via the event. The listener is then stopped, and the process exits.
    """
    logging.config.dictConfig(config)
    listener = logging.handlers.QueueListener(q, MyHandler())
    listener.start()
    if os.name == 'posix':
        # On POSIX, the setup logger will have been configured in the
        # parent process, but should have been disabled following the
        # dictConfig call.
        # On Windows, since fork isn't used, the setup logger won't
        # exist in the child, so it would be created and the message
        # would appear - hence the "if posix" clause.
        logger = logging.getLogger('setup')
        logger.critical('Should not appear, because of disabled logger ...')
    stop_event.wait()
    listener.stop()

def worker_process(config):
    """
    A number of these are spawned for the purpose of illustration. In
    practice, they could be a heterogeneous bunch of processes rather than
    ones which are identical to each other.

    This initialises logging according to the specified configuration,
    and logs a hundred messages with random levels to randomly selected
    loggers.

    A small sleep is added to allow other processes a chance to run. This
    is not strictly needed, but it mixes the output from the different
    processes a bit more than if it's left out.
    """
    logging.config.dictConfig(config)
    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,
              logging.CRITICAL]
    loggers = ['foo', 'foo.bar', 'foo.bar.baz',
               'spam', 'spam.ham', 'spam.ham.eggs']
    if os.name == 'posix':
        # On POSIX, the setup logger will have been configured in the
        # parent process, but should have been disabled following the
        # dictConfig call.
        # On Windows, since fork isn't used, the setup logger won't
        # exist in the child, so it would be created and the message
        # would appear - hence the "if posix" clause.
        logger = logging.getLogger('setup')
        logger.critical('Should not appear, because of disabled logger ...')
    for i in range(100):
        lvl = random.choice(levels)
        logger = logging.getLogger(random.choice(loggers))
        logger.log(lvl, 'Message no. %d', i)
        time.sleep(0.01)

def main():
    q = Queue()
    # The main process gets a simple configuration which prints to the console.
    config_initial = {
        'version': 1,
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'level': 'INFO'
            }
        },
        'root': {
            'handlers': ['console'],
            'level': 'DEBUG'
        }
    }
    # The worker process configuration is just a QueueHandler attached to the
    # root logger, which allows all messages to be sent to the queue.
    # We disable existing loggers to disable the "setup" logger used in the
    # parent process. This is needed on POSIX because the logger will
    # be there in the child following a fork().
    config_worker = {
        'version': 1,
        'disable_existing_loggers': True,
        'handlers': {
            'queue': {
                'class': 'logging.handlers.QueueHandler',
                'queue': q
            }
        },
        'root': {
            'handlers': ['queue'],
            'level': 'DEBUG'
        }
    }
    # The listener process configuration shows that the full flexibility of
    # logging configuration is available to dispatch events to handlers however
    # you want.
    # We disable existing loggers to disable the "setup" logger used in the
    # parent process. This is needed on POSIX because the logger will
    # be there in the child following a fork().
    config_listener = {
        'version': 1,
        'disable_existing_loggers': True,
        'formatters': {
            'detailed': {
                'class': 'logging.Formatter',
                'format': '%(asctime)s %(name)-15s %(levelname)-8s %(processName)-10s %(message)s'
            },
            'simple': {
                'class': 'logging.Formatter',
                'format': '%(name)-15s %(levelname)-8s %(processName)-10s %(message)s'
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'formatter': 'simple',
                'level': 'INFO'
            },
            'file': {
                'class': 'logging.FileHandler',
                'filename': 'mplog.log',
                'mode': 'w',
                'formatter': 'detailed'
            },
            'foofile': {
                'class': 'logging.FileHandler',
                'filename': 'mplog-foo.log',
                'mode': 'w',
                'formatter': 'detailed'
            },
            'errors': {
                'class': 'logging.FileHandler',
                'filename': 'mplog-errors.log',
                'mode': 'w',
                'formatter': 'detailed',
                'level': 'ERROR'
            }
        },
        'loggers': {
            'foo': {
                'handlers': ['foofile']
            }
        },
        'root': {
            'handlers': ['console', 'file', 'errors'],
            'level': 'DEBUG'
        }
    }
    # Log some initial events, just to show that logging in the parent works
    # normally.
    logging.config.dictConfig(config_initial)
    logger = logging.getLogger('setup')
    logger.info('About to create workers ...')
    workers = []
    for i in range(5):
        wp = Process(target=worker_process, name='worker %d' % (i + 1),
                     args=(config_worker,))
        workers.append(wp)
        wp.start()
        logger.info('Started worker: %s', wp.name)
    logger.info('About to create listener ...')
    stop_event = Event()
    lp = Process(target=listener_process, name='listener',
                 args=(q, stop_event, config_listener))
    lp.start()
    logger.info('Started listener')
    # We now hang around for the workers to finish their work.
    for wp in workers:
        wp.join()
    # Workers all done, listening can now stop.
    # Logging in the parent still works normally.
    logger.info('Telling listener to stop ...')
    stop_event.set()
    lp.join()
    logger.info('All done.')

if __name__ == '__main__':
    main()
</code></pre>
</section>
<section id="inserting-a-bom-into-messages-sent-to-a-sysloghandler" class="level2">
<h2 class="anchored" data-anchor-id="inserting-a-bom-into-messages-sent-to-a-sysloghandler">Inserting a BOM into messages sent to a SysLogHandler<a href="https://docs.python.org/3/howto/logging-cookbook.html#inserting-a-bom-into-messages-sent-to-a-sysloghandler" title="Link to this heading">¶</a></h2>
<p><a href="https://datatracker.ietf.org/doc/html/rfc5424.html"><strong>RFC 5424</strong></a> requires that a Unicode message be sent to a syslog daemon as a set of bytes which have the following structure: an optional pure-ASCII component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode encoded using UTF-8. (See the <a href="https://datatracker.ietf.org/doc/html/rfc5424.html#section-6"><strong>relevant section of the specification</strong></a>.)</p>
<p>In Python 3.1, code was added to <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code>SysLogHandler</code></a> to insert a BOM into the message, but unfortunately, it was implemented incorrectly, with the BOM appearing at the beginning of the message and hence not allowing any pure-ASCII component to appear before it.</p>
<p>As this behaviour is broken, the incorrect BOM insertion code is being removed from Python 3.2.4 and later. However, it is not being replaced, and if you want to produce <a href="https://datatracker.ietf.org/doc/html/rfc5424.html"><strong>RFC 5424</strong></a>-compliant messages which include a BOM, an optional pure-ASCII sequence before it and arbitrary Unicode after it, encoded using UTF-8, then you need to do the following:</p>
<ol type="1">
<li><p>Attach a <a href="https://docs.python.org/3/library/logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> instance to your <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code>SysLogHandler</code></a> instance, with a format string such as:</p>
<pre><code>'ASCII section\ufeffUnicode section'
</code></pre>
<p>The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as a UTF-8 BOM – the byte-string <code>b'\xef\xbb\xbf'</code>.</p></li>
<li><p>Replace the ASCII section with whatever placeholders you like, but make sure that the data that appears in there after substitution is always ASCII (that way, it will remain unchanged after UTF-8 encoding).</p></li>
<li><p>Replace the Unicode section with whatever placeholders you like; if the data which appears there after substitution contains characters outside the ASCII range, that’s fine – it will be encoded using UTF-8.</p></li>
</ol>
<p>The formatted message <em>will</em> be encoded using UTF-8 encoding by <code>SysLogHandler</code>. If you follow the above rules, you should be able to produce <a href="https://datatracker.ietf.org/doc/html/rfc5424.html"><strong>RFC 5424</strong></a>-compliant messages. If you don’t, logging may not complain, but your messages will not be RFC 5424-compliant, and your syslog daemon may complain.</p>
</section>
<section id="implementing-structured-logging" class="level2">
<h2 class="anchored" data-anchor-id="implementing-structured-logging">Implementing structured logging<a href="https://docs.python.org/3/howto/logging-cookbook.html#implementing-structured-logging" title="Link to this heading">¶</a></h2>
<p>Although most logging messages are intended for reading by humans, and thus not readily machine-parseable, there might be circumstances where you want to output messages in a structured format which <em>is</em> capable of being parsed by a program (without needing complex regular expressions to parse the log message). This is straightforward to achieve using the logging package. There are a number of ways in which this could be achieved, but the following is a simple approach which uses JSON to serialise the event in a machine-parseable manner:</p>
<pre><code>import json
import logging

class StructuredMessage:
    def __init__(self, message, /, **kwargs):
        self.message = message
        self.kwargs = kwargs

    def __str__(self):
        return '%s &gt;&gt;&gt; %s' % (self.message, json.dumps(self.kwargs))

_ = StructuredMessage   # optional, to improve readability

logging.basicConfig(level=logging.INFO, format='%(message)s')
logging.info(_('message 1', foo='bar', bar='baz', num=123, fnum=123.456))
</code></pre>
<p>If the above script is run, it prints:</p>
<pre><code>message 1 &gt;&gt;&gt; {"fnum": 123.456, "num": 123, "bar": "baz", "foo": "bar"}
</code></pre>
<p>Note that the order of items might be different according to the version of Python used.</p>
<p>If you need more specialised processing, you can use a custom JSON encoder, as in the following complete example:</p>
<pre><code>import json
import logging


class Encoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, set):
            return tuple(o)
        elif isinstance(o, str):
            return o.encode('unicode_escape').decode('ascii')
        return super().default(o)

class StructuredMessage:
    def __init__(self, message, /, **kwargs):
        self.message = message
        self.kwargs = kwargs

    def __str__(self):
        s = Encoder().encode(self.kwargs)
        return '%s &gt;&gt;&gt; %s' % (self.message, s)

_ = StructuredMessage   # optional, to improve readability

def main():
    logging.basicConfig(level=logging.INFO, format='%(message)s')
    logging.info(_('message 1', set_value={1, 2, 3}, snowman='\u2603'))

if __name__ == '__main__':
    main()
</code></pre>
<p>When the above script is run, it prints:</p>
<pre><code>message 1 &gt;&gt;&gt; {"snowman": "\u2603", "set_value": [1, 2, 3]}
</code></pre>
<p>Note that the order of items might be different according to the version of Python used.</p>
</section>
<section id="customizing-handlers-with-dictconfig" class="level2">
<h2 class="anchored" data-anchor-id="customizing-handlers-with-dictconfig">Customizing handlers with <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a><a href="https://docs.python.org/3/howto/logging-cookbook.html#customizing-handlers-with-dictconfig" title="Link to this heading">¶</a></h2>
<p>There are times when you want to customize logging handlers in particular ways, and if you use <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> you may be able to do this without subclassing. As an example, consider that you may want to set the ownership of a log file. On POSIX, this is easily done using <a href="https://docs.python.org/3/library/shutil.html#shutil.chown" title="shutil.chown"><code>shutil.chown()</code></a>, but the file handlers in the stdlib don’t offer built-in support. You can customize handler creation using a plain function such as:</p>
<pre><code>def owned_file_handler(filename, mode='a', encoding=None, owner=None):
    if owner:
        if not os.path.exists(filename):
            open(filename, 'a').close()
        shutil.chown(filename, *owner)
    return logging.FileHandler(filename, mode, encoding)
</code></pre>
<p>You can then specify, in a logging configuration passed to <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a>, that a logging handler be created by calling this function:</p>
<pre><code>LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'default': {
            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'
        },
    },
    'handlers': {
        'file':{
            # The values below are popped from this dictionary and
            # used to create the handler, set the handler's level and
            # its formatter.
            '()': owned_file_handler,
            'level':'DEBUG',
            'formatter': 'default',
            # The values below are passed to the handler creator callable
            # as keyword arguments.
            'owner': ['pulse', 'pulse'],
            'filename': 'chowntest.log',
            'mode': 'w',
            'encoding': 'utf-8',
        },
    },
    'root': {
        'handlers': ['file'],
        'level': 'DEBUG',
    },
}
</code></pre>
<p>In this example I am setting the ownership using the <code>pulse</code> user and group, just for the purposes of illustration. Putting it together into a working script, <code>chowntest.py</code>:</p>
<pre><code>import logging, logging.config, os, shutil

def owned_file_handler(filename, mode='a', encoding=None, owner=None):
    if owner:
        if not os.path.exists(filename):
            open(filename, 'a').close()
        shutil.chown(filename, *owner)
    return logging.FileHandler(filename, mode, encoding)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'default': {
            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'
        },
    },
    'handlers': {
        'file':{
            # The values below are popped from this dictionary and
            # used to create the handler, set the handler's level and
            # its formatter.
            '()': owned_file_handler,
            'level':'DEBUG',
            'formatter': 'default',
            # The values below are passed to the handler creator callable
            # as keyword arguments.
            'owner': ['pulse', 'pulse'],
            'filename': 'chowntest.log',
            'mode': 'w',
            'encoding': 'utf-8',
        },
    },
    'root': {
        'handlers': ['file'],
        'level': 'DEBUG',
    },
}

logging.config.dictConfig(LOGGING)
logger = logging.getLogger('mylogger')
logger.debug('A debug message')
</code></pre>
<p>To run this, you will probably need to run as <code>root</code>:</p>
<pre><code>$ sudo python3.3 chowntest.py
$ cat chowntest.log
2013-11-05 09:34:51,128 DEBUG mylogger A debug message
$ ls -l chowntest.log
-rw-r--r-- 1 pulse pulse 55 2013-11-05 09:34 chowntest.log
</code></pre>
<p>Note that this example uses Python 3.3 because that’s where <a href="https://docs.python.org/3/library/shutil.html#shutil.chown" title="shutil.chown"><code>shutil.chown()</code></a> makes an appearance. This approach should work with any Python version that supports <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> - namely, Python 2.7, 3.2 or later. With pre-3.3 versions, you would need to implement the actual ownership change using e.g.&nbsp;<a href="https://docs.python.org/3/library/os.html#os.chown" title="os.chown"><code>os.chown()</code></a>.</p>
<p>In practice, the handler-creating function may be in a utility module somewhere in your project. Instead of the line in the configuration:</p>
<pre><code>'()': owned_file_handler,
</code></pre>
<p>you could use e.g.:</p>
<pre><code>'()': 'ext://project.util.owned_file_handler',
</code></pre>
<p>where <code>project.util</code> can be replaced with the actual name of the package where the function resides. In the above working script, using <code>'ext://__main__.owned_file_handler'</code> should work. Here, the actual callable is resolved by <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> from the <code>ext://</code> specification.</p>
<p>This example hopefully also points the way to how you could implement other types of file change - e.g.&nbsp;setting specific POSIX permission bits - in the same way, using <a href="https://docs.python.org/3/library/os.html#os.chmod" title="os.chmod"><code>os.chmod()</code></a>.</p>
<p>Of course, the approach could also be extended to types of handler other than a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.FileHandler" title="logging.FileHandler"><code>FileHandler</code></a> - for example, one of the rotating file handlers, or a different type of handler altogether.</p>
</section>
<section id="using-particular-formatting-styles-throughout-your-application" class="level2">
<h2 class="anchored" data-anchor-id="using-particular-formatting-styles-throughout-your-application">Using particular formatting styles throughout your application<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-particular-formatting-styles-throughout-your-application" title="Link to this heading">¶</a></h2>
<p>In Python 3.2, the <a href="https://docs.python.org/3/library/logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> gained a <code>style</code> keyword parameter which, while defaulting to <code>%</code> for backward compatibility, allowed the specification of <code>{</code> or <code>$</code> to support the formatting approaches supported by <a href="https://docs.python.org/3/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> and <a href="https://docs.python.org/3/library/string.html#string.Template" title="string.Template"><code>string.Template</code></a>. Note that this governs the formatting of logging messages for final output to logs, and is completely orthogonal to how an individual logging message is constructed.</p>
<p>Logging calls (<a href="https://docs.python.org/3/library/logging.html#logging.Logger.debug" title="logging.Logger.debug"><code>debug()</code></a>, <a href="https://docs.python.org/3/library/logging.html#logging.Logger.info" title="logging.Logger.info"><code>info()</code></a> etc.) only take positional parameters for the actual logging message itself, with keyword parameters used only for determining options for how to handle the logging call (e.g.&nbsp;the <code>exc_info</code> keyword parameter to indicate that traceback information should be logged, or the <code>extra</code> keyword parameter to indicate additional contextual information to be added to the log). So you cannot directly make logging calls using <a href="https://docs.python.org/3/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> or <a href="https://docs.python.org/3/library/string.html#string.Template" title="string.Template"><code>string.Template</code></a> syntax, because internally the logging package uses %-formatting to merge the format string and the variable arguments. There would be no changing this while preserving backward compatibility, since all logging calls which are out there in existing code will be using %-format strings.</p>
<p>There have been suggestions to associate format styles with specific loggers, but that approach also runs into backward compatibility problems because any existing code could be using a given logger name and using %-formatting.</p>
<p>For logging to work interoperably between any third-party libraries and your code, decisions about formatting need to be made at the level of the individual logging call. This opens up a couple of ways in which alternative formatting styles can be accommodated.</p>
<section id="using-logrecord-factories" class="level3">
<h3 class="anchored" data-anchor-id="using-logrecord-factories">Using LogRecord factories<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-logrecord-factories" title="Link to this heading">¶</a></h3>
<p>In Python 3.2, along with the <a href="https://docs.python.org/3/library/logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> changes mentioned above, the logging package gained the ability to allow users to set their own <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> subclasses, using the <a href="https://docs.python.org/3/library/logging.html#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code>setLogRecordFactory()</code></a> function. You can use this to set your own subclass of <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a>, which does the Right Thing by overriding the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord.getMessage" title="logging.LogRecord.getMessage"><code>getMessage()</code></a> method. The base class implementation of this method is where the <code>msg % args</code> formatting happens, and where you can substitute your alternate formatting; however, you should be careful to support all formatting styles and allow %-formatting as the default, to ensure interoperability with other code. Care should also be taken to call <code>str(self.msg)</code>, just as the base implementation does.</p>
<p>Refer to the reference documentation on <a href="https://docs.python.org/3/library/logging.html#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code>setLogRecordFactory()</code></a> and <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> for more information.</p>
</section>
<section id="using-custom-message-objects" class="level3">
<h3 class="anchored" data-anchor-id="using-custom-message-objects">Using custom message objects<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-custom-message-objects" title="Link to this heading">¶</a></h3>
<p>There is another, perhaps simpler way that you can use {}- and $- formatting to construct your individual log messages. You may recall (from <a href="https://docs.python.org/3/howto/logging.html#arbitrary-object-messages">Using arbitrary objects as messages</a>) that when logging you can use an arbitrary object as a message format string, and that the logging package will call <a href="https://docs.python.org/3/library/stdtypes.html#str" title="str"><code>str()</code></a> on that object to get the actual format string. Consider the following two classes:</p>
<pre><code>class BraceMessage:
    def __init__(self, fmt, /, *args, **kwargs):
        self.fmt = fmt
        self.args = args
        self.kwargs = kwargs

    def __str__(self):
        return self.fmt.format(*self.args, **self.kwargs)

class DollarMessage:
    def __init__(self, fmt, /, **kwargs):
        self.fmt = fmt
        self.kwargs = kwargs

    def __str__(self):
        from string import Template
        return Template(self.fmt).substitute(**self.kwargs)
</code></pre>
<p>Either of these can be used in place of a format string, to allow {}- or <span class="math inline">\(-formatting to be used to build the actual “message” part which appears in the formatted log output in place of “%(message)s” or “{message}” or “\)</span>message”. If you find it a little unwieldy to use the class names whenever you want to log something, you can make it more palatable if you use an alias such as <code>M</code> or <code>_</code> for the message (or perhaps <code>__</code>, if you are using <code>_</code> for localization).</p>
<p>Examples of this approach are given below. Firstly, formatting with <a href="https://docs.python.org/3/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a>:</p>
<p>&gt;&gt;&gt;</p>
<pre><code>&gt;&gt;&gt; __ = BraceMessage
&gt;&gt;&gt; print(__('Message with {0} {1}', 2, 'placeholders'))
Message with 2 placeholders
&gt;&gt;&gt; class Point: pass
...
&gt;&gt;&gt; p = Point()
&gt;&gt;&gt; p.x = 0.5
&gt;&gt;&gt; p.y = 0.5
&gt;&gt;&gt; print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})', point=p))
Message with coordinates: (0.50, 0.50)
</code></pre>
<p>Secondly, formatting with <a href="https://docs.python.org/3/library/string.html#string.Template" title="string.Template"><code>string.Template</code></a>:</p>
<p>&gt;&gt;&gt;</p>
<pre><code>&gt;&gt;&gt; __ = DollarMessage
&gt;&gt;&gt; print(__('Message with $num $what', num=2, what='placeholders'))
Message with 2 placeholders
&gt;&gt;&gt;
</code></pre>
<p>One thing to note is that you pay no significant performance penalty with this approach: the actual formatting happens not when you make the logging call, but when (and if) the logged message is actually about to be output to a log by a handler. So the only slightly unusual thing which might trip you up is that the parentheses go around the format string and the arguments, not just the format string. That’s because the __ notation is just syntax sugar for a constructor call to one of the <code>_XXX_Message</code> classes shown above.</p>
</section>
</section>
<section id="configuring-filters-with-dictconfig" class="level2">
<h2 class="anchored" data-anchor-id="configuring-filters-with-dictconfig">Configuring filters with <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a><a href="https://docs.python.org/3/howto/logging-cookbook.html#configuring-filters-with-dictconfig" title="Link to this heading">¶</a></h2>
<p>You <em>can</em> configure filters using <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a>, though it might not be obvious at first glance how to do it (hence this recipe). Since <a href="https://docs.python.org/3/library/logging.html#logging.Filter" title="logging.Filter"><code>Filter</code></a> is the only filter class included in the standard library, and it is unlikely to cater to many requirements (it’s only there as a base class), you will typically need to define your own <a href="https://docs.python.org/3/library/logging.html#logging.Filter" title="logging.Filter"><code>Filter</code></a> subclass with an overridden <a href="https://docs.python.org/3/library/logging.html#logging.Filter.filter" title="logging.Filter.filter"><code>filter()</code></a> method. To do this, specify the <code>()</code> key in the configuration dictionary for the filter, specifying a callable which will be used to create the filter (a class is the most obvious, but you can provide any callable which returns a <a href="https://docs.python.org/3/library/logging.html#logging.Filter" title="logging.Filter"><code>Filter</code></a> instance). Here is a complete example:</p>
<pre><code>import logging
import logging.config
import sys

class MyFilter(logging.Filter):
    def __init__(self, param=None):
        self.param = param

    def filter(self, record):
        if self.param is None:
            allow = True
        else:
            allow = self.param not in record.msg
        if allow:
            record.msg = 'changed: ' + record.msg
        return allow

LOGGING = {
    'version': 1,
    'filters': {
        'myfilter': {
            '()': MyFilter,
            'param': 'noshow',
        }
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'filters': ['myfilter']
        }
    },
    'root': {
        'level': 'DEBUG',
        'handlers': ['console']
    },
}

if __name__ == '__main__':
    logging.config.dictConfig(LOGGING)
    logging.debug('hello')
    logging.debug('hello - noshow')
</code></pre>
<p>This example shows how you can pass configuration data to the callable which constructs the instance, in the form of keyword parameters. When run, the above script will print:</p>
<p>which shows that the filter is working as configured.</p>
<p>A couple of extra points to note:</p>
<ul>
<li><p>If you can’t refer to the callable directly in the configuration (e.g.&nbsp;if it lives in a different module, and you can’t import it directly where the configuration dictionary is), you can use the form <code>ext://...</code> as described in <a href="https://docs.python.org/3/library/logging.config.html#logging-config-dict-externalobj">Access to external objects</a>. For example, you could have used the text <code>'ext://__main__.MyFilter'</code> instead of <code>MyFilter</code> in the above example.</p></li>
<li><p>As well as for filters, this technique can also be used to configure custom handlers and formatters. See <a href="https://docs.python.org/3/library/logging.config.html#logging-config-dict-userdef">User-defined objects</a> for more information on how logging supports using user-defined objects in its configuration, and see the other cookbook recipe <a href="https://docs.python.org/3/howto/logging-cookbook.html#custom-handlers">Customizing handlers with dictConfig()</a> above.</p></li>
</ul>
</section>
<section id="customized-exception-formatting" class="level2">
<h2 class="anchored" data-anchor-id="customized-exception-formatting">Customized exception formatting<a href="https://docs.python.org/3/howto/logging-cookbook.html#customized-exception-formatting" title="Link to this heading">¶</a></h2>
<p>There might be times when you want to do customized exception formatting - for argument’s sake, let’s say you want exactly one line per logged event, even when exception information is present. You can do this with a custom formatter class, as shown in the following example:</p>
<pre><code>import logging

class OneLineExceptionFormatter(logging.Formatter):
    def formatException(self, exc_info):
        """
        Format an exception so that it prints on a single line.
        """
        result = super().formatException(exc_info)
        return repr(result)  # or format into one line however you want to

    def format(self, record):
        s = super().format(record)
        if record.exc_text:
            s = s.replace('\n', '') + '|'
        return s

def configure_logging():
    fh = logging.FileHandler('output.txt', 'w')
    f = OneLineExceptionFormatter('%(asctime)s|%(levelname)s|%(message)s|',
                                  '%d/%m/%Y %H:%M:%S')
    fh.setFormatter(f)
    root = logging.getLogger()
    root.setLevel(logging.DEBUG)
    root.addHandler(fh)

def main():
    configure_logging()
    logging.info('Sample message')
    try:
        x = 1 / 0
    except ZeroDivisionError as e:
        logging.exception('ZeroDivisionError: %s', e)

if __name__ == '__main__':
    main()
</code></pre>
<p>When run, this produces a file with exactly two lines:</p>
<pre><code>28/01/2015 07:21:23|INFO|Sample message|
28/01/2015 07:21:23|ERROR|ZeroDivisionError: integer division or modulo by zero|'Traceback (most recent call last):\n  File "logtest7.py", line 30, in main\n    x = 1 / 0\nZeroDivisionError: integer division or modulo by zero'|
</code></pre>
<p>While the above treatment is simplistic, it points the way to how exception information can be formatted to your liking. The <a href="https://docs.python.org/3/library/traceback.html#module-traceback" title="traceback: Print or retrieve a stack traceback."><code>traceback</code></a> module may be helpful for more specialized needs.</p>
</section>
<section id="speaking-logging-messages" class="level2">
<h2 class="anchored" data-anchor-id="speaking-logging-messages">Speaking logging messages<a href="https://docs.python.org/3/howto/logging-cookbook.html#speaking-logging-messages" title="Link to this heading">¶</a></h2>
<p>There might be situations when it is desirable to have logging messages rendered in an audible rather than a visible format. This is easy to do if you have text-to-speech (TTS) functionality available in your system, even if it doesn’t have a Python binding. Most TTS systems have a command line program you can run, and this can be invoked from a handler using <a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code>subprocess</code></a>. It’s assumed here that TTS command line programs won’t expect to interact with users or take a long time to complete, and that the frequency of logged messages will be not so high as to swamp the user with messages, and that it’s acceptable to have the messages spoken one at a time rather than concurrently, The example implementation below waits for one message to be spoken before the next is processed, and this might cause other handlers to be kept waiting. Here is a short example showing the approach, which assumes that the <code>espeak</code> TTS package is available:</p>
<pre><code>import logging
import subprocess
import sys

class TTSHandler(logging.Handler):
    def emit(self, record):
        msg = self.format(record)
        # Speak slowly in a female English voice
        cmd = ['espeak', '-s150', '-ven+f3', msg]
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        # wait for the program to finish
        p.communicate()

def configure_logging():
    h = TTSHandler()
    root = logging.getLogger()
    root.addHandler(h)
    # the default formatter just returns the message
    root.setLevel(logging.DEBUG)

def main():
    logging.info('Hello')
    logging.debug('Goodbye')

if __name__ == '__main__':
    configure_logging()
    sys.exit(main())
</code></pre>
<p>When run, this script should say “Hello” and then “Goodbye” in a female voice.</p>
<p>The above approach can, of course, be adapted to other TTS systems and even other systems altogether which can process messages via external programs run from a command line.</p>
</section>
<section id="buffering-logging-messages-and-outputting-them-conditionally" class="level2">
<h2 class="anchored" data-anchor-id="buffering-logging-messages-and-outputting-them-conditionally">Buffering logging messages and outputting them conditionally<a href="https://docs.python.org/3/howto/logging-cookbook.html#buffering-logging-messages-and-outputting-them-conditionally" title="Link to this heading">¶</a></h2>
<p>There might be situations where you want to log messages in a temporary area and only output them if a certain condition occurs. For example, you may want to start logging debug events in a function, and if the function completes without errors, you don’t want to clutter the log with the collected debug information, but if there is an error, you want all the debug information to be output as well as the error.</p>
<p>Here is an example which shows how you could do this using a decorator for your functions where you want logging to behave this way. It makes use of the <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code>logging.handlers.MemoryHandler</code></a>, which allows buffering of logged events until some condition occurs, at which point the buffered events are <code>flushed</code> - passed to another handler (the <code>target</code> handler) for processing. By default, the <code>MemoryHandler</code> flushed when its buffer gets filled up or an event whose level is greater than or equal to a specified threshold is seen. You can use this recipe with a more specialised subclass of <code>MemoryHandler</code> if you want custom flushing behavior.</p>
<p>The example script has a simple function, <code>foo</code>, which just cycles through all the logging levels, writing to <code>sys.stderr</code> to say what level it’s about to log at, and then actually logging a message at that level. You can pass a parameter to <code>foo</code> which, if true, will log at ERROR and CRITICAL levels - otherwise, it only logs at DEBUG, INFO and WARNING levels.</p>
<p>The script just arranges to decorate <code>foo</code> with a decorator which will do the conditional logging that’s required. The decorator takes a logger as a parameter and attaches a memory handler for the duration of the call to the decorated function. The decorator can be additionally parameterised using a target handler, a level at which flushing should occur, and a capacity for the buffer (number of records buffered). These default to a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code>StreamHandler</code></a> which writes to <code>sys.stderr</code>, <code>logging.ERROR</code> and <code>100</code> respectively.</p>
<p>Here’s the script:</p>
<pre><code>import logging
from logging.handlers import MemoryHandler
import sys

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

def log_if_errors(logger, target_handler=None, flush_level=None, capacity=None):
    if target_handler is None:
        target_handler = logging.StreamHandler()
    if flush_level is None:
        flush_level = logging.ERROR
    if capacity is None:
        capacity = 100
    handler = MemoryHandler(capacity, flushLevel=flush_level, target=target_handler)

    def decorator(fn):
        def wrapper(*args, **kwargs):
            logger.addHandler(handler)
            try:
                return fn(*args, **kwargs)
            except Exception:
                logger.exception('call failed')
                raise
            finally:
                super(MemoryHandler, handler).flush()
                logger.removeHandler(handler)
        return wrapper

    return decorator

def write_line(s):
    sys.stderr.write('%s\n' % s)

def foo(fail=False):
    write_line('about to log at DEBUG ...')
    logger.debug('Actually logged at DEBUG')
    write_line('about to log at INFO ...')
    logger.info('Actually logged at INFO')
    write_line('about to log at WARNING ...')
    logger.warning('Actually logged at WARNING')
    if fail:
        write_line('about to log at ERROR ...')
        logger.error('Actually logged at ERROR')
        write_line('about to log at CRITICAL ...')
        logger.critical('Actually logged at CRITICAL')
    return fail

decorated_foo = log_if_errors(logger)(foo)

if __name__ == '__main__':
    logger.setLevel(logging.DEBUG)
    write_line('Calling undecorated foo with False')
    assert not foo(False)
    write_line('Calling undecorated foo with True')
    assert foo(True)
    write_line('Calling decorated foo with False')
    assert not decorated_foo(False)
    write_line('Calling decorated foo with True')
    assert decorated_foo(True)
</code></pre>
<p>When this script is run, the following output should be observed:</p>
<pre><code>Calling undecorated foo with False
about to log at DEBUG ...
about to log at INFO ...
about to log at WARNING ...
Calling undecorated foo with True
about to log at DEBUG ...
about to log at INFO ...
about to log at WARNING ...
about to log at ERROR ...
about to log at CRITICAL ...
Calling decorated foo with False
about to log at DEBUG ...
about to log at INFO ...
about to log at WARNING ...
Calling decorated foo with True
about to log at DEBUG ...
about to log at INFO ...
about to log at WARNING ...
about to log at ERROR ...
Actually logged at DEBUG
Actually logged at INFO
Actually logged at WARNING
Actually logged at ERROR
about to log at CRITICAL ...
Actually logged at CRITICAL
</code></pre>
<p>As you can see, actual logging output only occurs when an event is logged whose severity is ERROR or greater, but in that case, any previous events at lower severities are also logged.</p>
<p>You can of course use the conventional means of decoration:</p>
<pre><code>@log_if_errors(logger)
def foo(fail=False):
    ...
</code></pre>
</section>
<section id="sending-logging-messages-to-email-with-buffering" class="level2">
<h2 class="anchored" data-anchor-id="sending-logging-messages-to-email-with-buffering">Sending logging messages to email, with buffering<a href="https://docs.python.org/3/howto/logging-cookbook.html#sending-logging-messages-to-email-with-buffering" title="Link to this heading">¶</a></h2>
<p>To illustrate how you can send log messages via email, so that a set number of messages are sent per email, you can subclass <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.BufferingHandler" title="logging.handlers.BufferingHandler"><code>BufferingHandler</code></a>. In the following example, which you can adapt to suit your specific needs, a simple test harness is provided which allows you to run the script with command line arguments specifying what you typically need to send things via SMTP. (Run the downloaded script with the <code>-h</code> argument to see the required and optional arguments.)</p>
<pre><code>import logging
import logging.handlers
import smtplib

class BufferingSMTPHandler(logging.handlers.BufferingHandler):
    def __init__(self, mailhost, port, username, password, fromaddr, toaddrs,
                 subject, capacity):
        logging.handlers.BufferingHandler.__init__(self, capacity)
        self.mailhost = mailhost
        self.mailport = port
        self.username = username
        self.password = password
        self.fromaddr = fromaddr
        if isinstance(toaddrs, str):
            toaddrs = [toaddrs]
        self.toaddrs = toaddrs
        self.subject = subject
        self.setFormatter(logging.Formatter("%(asctime)s %(levelname)-5s %(message)s"))

    def flush(self):
        if len(self.buffer) &gt; 0:
            try:
                smtp = smtplib.SMTP(self.mailhost, self.mailport)
                smtp.starttls()
                smtp.login(self.username, self.password)
                msg = "From: %s\r\nTo: %s\r\nSubject: %s\r\n\r\n" % (self.fromaddr, ','.join(self.toaddrs), self.subject)
                for record in self.buffer:
                    s = self.format(record)
                    msg = msg + s + "\r\n"
                smtp.sendmail(self.fromaddr, self.toaddrs, msg)
                smtp.quit()
            except Exception:
                if logging.raiseExceptions:
                    raise
            self.buffer = []

if __name__ == '__main__':
    import argparse

    ap = argparse.ArgumentParser()
    aa = ap.add_argument
    aa('host', metavar='HOST', help='SMTP server')
    aa('--port', '-p', type=int, default=587, help='SMTP port')
    aa('user', metavar='USER', help='SMTP username')
    aa('password', metavar='PASSWORD', help='SMTP password')
    aa('to', metavar='TO', help='Addressee for emails')
    aa('sender', metavar='SENDER', help='Sender email address')
    aa('--subject', '-s',
       default='Test Logging email from Python logging module (buffering)',
       help='Subject of email')
    options = ap.parse_args()
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    h = BufferingSMTPHandler(options.host, options.port, options.user,
                             options.password, options.sender,
                             options.to, options.subject, 10)
    logger.addHandler(h)
    for i in range(102):
        logger.info("Info index = %d", i)
    h.flush()
    h.close()
</code></pre>
<p>If you run this script and your SMTP server is correctly set up, you should find that it sends eleven emails to the addressee you specify. The first ten emails will each have ten log messages, and the eleventh will have two messages. That makes up 102 messages as specified in the script.</p>
</section>
<section id="formatting-times-using-utc-gmt-via-configuration" class="level2">
<h2 class="anchored" data-anchor-id="formatting-times-using-utc-gmt-via-configuration">Formatting times using UTC (GMT) via configuration<a href="https://docs.python.org/3/howto/logging-cookbook.html#formatting-times-using-utc-gmt-via-configuration" title="Link to this heading">¶</a></h2>
<p>Sometimes you want to format times using UTC, which can be done using a class such as <code>UTCFormatter</code>, shown below:</p>
<pre><code>import logging
import time

class UTCFormatter(logging.Formatter):
    converter = time.gmtime
</code></pre>
<p>and you can then use the <code>UTCFormatter</code> in your code instead of <a href="https://docs.python.org/3/library/logging.html#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a>. If you want to do that via configuration, you can use the <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code>dictConfig()</code></a> API with an approach illustrated by the following complete example:</p>
<pre><code>import logging
import logging.config
import time

class UTCFormatter(logging.Formatter):
    converter = time.gmtime

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'utc': {
            '()': UTCFormatter,
            'format': '%(asctime)s %(message)s',
        },
        'local': {
            'format': '%(asctime)s %(message)s',
        }
    },
    'handlers': {
        'console1': {
            'class': 'logging.StreamHandler',
            'formatter': 'utc',
        },
        'console2': {
            'class': 'logging.StreamHandler',
            'formatter': 'local',
        },
    },
    'root': {
        'handlers': ['console1', 'console2'],
   }
}

if __name__ == '__main__':
    logging.config.dictConfig(LOGGING)
    logging.warning('The local time is %s', time.asctime())
</code></pre>
<p>When this script is run, it should print something like:</p>
<pre><code>2015-10-17 12:53:29,501 The local time is Sat Oct 17 13:53:29 2015
2015-10-17 13:53:29,501 The local time is Sat Oct 17 13:53:29 2015
</code></pre>
<p>showing how the time is formatted both as local time and UTC, one for each handler.</p>
</section>
<section id="using-a-context-manager-for-selective-logging" class="level2">
<h2 class="anchored" data-anchor-id="using-a-context-manager-for-selective-logging">Using a context manager for selective logging<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-a-context-manager-for-selective-logging" title="Link to this heading">¶</a></h2>
<p>There are times when it would be useful to temporarily change the logging configuration and revert it back after doing something. For this, a context manager is the most obvious way of saving and restoring the logging context. Here is a simple example of such a context manager, which allows you to optionally change the logging level and add a logging handler purely in the scope of the context manager:</p>
<pre><code>import logging
import sys

class LoggingContext:
    def __init__(self, logger, level=None, handler=None, close=True):
        self.logger = logger
        self.level = level
        self.handler = handler
        self.close = close

    def __enter__(self):
        if self.level is not None:
            self.old_level = self.logger.level
            self.logger.setLevel(self.level)
        if self.handler:
            self.logger.addHandler(self.handler)

    def __exit__(self, et, ev, tb):
        if self.level is not None:
            self.logger.setLevel(self.old_level)
        if self.handler:
            self.logger.removeHandler(self.handler)
        if self.handler and self.close:
            self.handler.close()
        # implicit return of None =&gt; don't swallow exceptions
</code></pre>
<p>If you specify a level value, the logger’s level is set to that value in the scope of the with block covered by the context manager. If you specify a handler, it is added to the logger on entry to the block and removed on exit from the block. You can also ask the manager to close the handler for you on block exit - you could do this if you don’t need the handler any more.</p>
<p>To illustrate how it works, we can add the following block of code to the above:</p>
<pre><code>if __name__ == '__main__':
    logger = logging.getLogger('foo')
    logger.addHandler(logging.StreamHandler())
    logger.setLevel(logging.INFO)
    logger.info('1. This should appear just once on stderr.')
    logger.debug('2. This should not appear.')
    with LoggingContext(logger, level=logging.DEBUG):
        logger.debug('3. This should appear once on stderr.')
    logger.debug('4. This should not appear.')
    h = logging.StreamHandler(sys.stdout)
    with LoggingContext(logger, level=logging.DEBUG, handler=h, close=True):
        logger.debug('5. This should appear twice - once on stderr and once on stdout.')
    logger.info('6. This should appear just once on stderr.')
    logger.debug('7. This should not appear.')
</code></pre>
<p>We initially set the logger’s level to <code>INFO</code>, so message #1 appears and message #2 doesn’t. We then change the level to <code>DEBUG</code> temporarily in the following <code>with</code> block, and so message #3 appears. After the block exits, the logger’s level is restored to <code>INFO</code> and so message #4 doesn’t appear. In the next <code>with</code> block, we set the level to <code>DEBUG</code> again but also add a handler writing to <code>sys.stdout</code>. Thus, message #5 appears twice on the console (once via <code>stderr</code> and once via <code>stdout</code>). After the <code>with</code> statement’s completion, the status is as it was before so message #6 appears (like message #1) whereas message #7 doesn’t (just like message #2).</p>
<p>If we run the resulting script, the result is as follows:</p>
<pre><code>$ python logctx.py
1. This should appear just once on stderr.
3. This should appear once on stderr.
5. This should appear twice - once on stderr and once on stdout.
5. This should appear twice - once on stderr and once on stdout.
6. This should appear just once on stderr.
</code></pre>
<p>If we run it again, but pipe <code>stderr</code> to <code>/dev/null</code>, we see the following, which is the only message written to <code>stdout</code>:</p>
<pre><code>$ python logctx.py 2&gt;/dev/null
5. This should appear twice - once on stderr and once on stdout.
</code></pre>
<p>Once again, but piping <code>stdout</code> to <code>/dev/null</code>, we get:</p>
<pre><code>$ python logctx.py &gt;/dev/null
1. This should appear just once on stderr.
3. This should appear once on stderr.
5. This should appear twice - once on stderr and once on stdout.
6. This should appear just once on stderr.
</code></pre>
<p>In this case, the message #5 printed to <code>stdout</code> doesn’t appear, as expected.</p>
<p>Of course, the approach described here can be generalised, for example to attach logging filters temporarily. Note that the above code works in Python 2 as well as Python 3.</p>
</section>
<section id="a-cli-application-starter-template" class="level2">
<h2 class="anchored" data-anchor-id="a-cli-application-starter-template">A CLI application starter template<a href="https://docs.python.org/3/howto/logging-cookbook.html#a-cli-application-starter-template" title="Link to this heading">¶</a></h2>
<p>Here’s an example which shows how you can:</p>
<ul>
<li><p>Use a logging level based on command-line arguments</p></li>
<li><p>Dispatch to multiple subcommands in separate files, all logging at the same level in a consistent way</p></li>
<li><p>Make use of simple, minimal configuration</p></li>
</ul>
<p>Suppose we have a command-line application whose job is to stop, start or restart some services. This could be organised for the purposes of illustration as a file <code>app.py</code> that is the main script for the application, with individual commands implemented in <code>start.py</code>, <code>stop.py</code> and <code>restart.py</code>. Suppose further that we want to control the verbosity of the application via a command-line argument, defaulting to <code>logging.INFO</code>. Here’s one way that <code>app.py</code> could be written:</p>
<pre><code>import argparse
import importlib
import logging
import os
import sys

def main(args=None):
    scriptname = os.path.basename(__file__)
    parser = argparse.ArgumentParser(scriptname)
    levels = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')
    parser.add_argument('--log-level', default='INFO', choices=levels)
    subparsers = parser.add_subparsers(dest='command',
                                       help='Available commands:')
    start_cmd = subparsers.add_parser('start', help='Start a service')
    start_cmd.add_argument('name', metavar='NAME',
                           help='Name of service to start')
    stop_cmd = subparsers.add_parser('stop',
                                     help='Stop one or more services')
    stop_cmd.add_argument('names', metavar='NAME', nargs='+',
                          help='Name of service to stop')
    restart_cmd = subparsers.add_parser('restart',
                                        help='Restart one or more services')
    restart_cmd.add_argument('names', metavar='NAME', nargs='+',
                             help='Name of service to restart')
    options = parser.parse_args()
    # the code to dispatch commands could all be in this file. For the purposes
    # of illustration only, we implement each command in a separate module.
    try:
        mod = importlib.import_module(options.command)
        cmd = getattr(mod, 'command')
    except (ImportError, AttributeError):
        print('Unable to find the code for command \'%s\'' % options.command)
        return 1
    # Could get fancy here and load configuration from file or dictionary
    logging.basicConfig(level=options.log_level,
                        format='%(levelname)s %(name)s %(message)s')
    cmd(options)

if __name__ == '__main__':
    sys.exit(main())
</code></pre>
<p>And the <code>start</code>, <code>stop</code> and <code>restart</code> commands can be implemented in separate modules, like so for starting:</p>
<pre><code># start.py
import logging

logger = logging.getLogger(__name__)

def command(options):
    logger.debug('About to start %s', options.name)
    # actually do the command processing here ...
    logger.info('Started the \'%s\' service.', options.name)
</code></pre>
<p>and thus for stopping:</p>
<pre><code># stop.py
import logging

logger = logging.getLogger(__name__)

def command(options):
    n = len(options.names)
    if n == 1:
        plural = ''
        services = '\'%s\'' % options.names[0]
    else:
        plural = 's'
        services = ', '.join('\'%s\'' % name for name in options.names)
        i = services.rfind(', ')
        services = services[:i] + ' and ' + services[i + 2:]
    logger.debug('About to stop %s', services)
    # actually do the command processing here ...
    logger.info('Stopped the %s service%s.', services, plural)
</code></pre>
<p>and similarly for restarting:</p>
<pre><code># restart.py
import logging

logger = logging.getLogger(__name__)

def command(options):
    n = len(options.names)
    if n == 1:
        plural = ''
        services = '\'%s\'' % options.names[0]
    else:
        plural = 's'
        services = ', '.join('\'%s\'' % name for name in options.names)
        i = services.rfind(', ')
        services = services[:i] + ' and ' + services[i + 2:]
    logger.debug('About to restart %s', services)
    # actually do the command processing here ...
    logger.info('Restarted the %s service%s.', services, plural)
</code></pre>
<p>If we run this application with the default log level, we get output like this:</p>
<pre><code>$ python app.py start foo
INFO start Started the 'foo' service.

$ python app.py stop foo bar
INFO stop Stopped the 'foo' and 'bar' services.

$ python app.py restart foo bar baz
INFO restart Restarted the 'foo', 'bar' and 'baz' services.
</code></pre>
<p>The first word is the logging level, and the second word is the module or package name of the place where the event was logged.</p>
<p>If we change the logging level, then we can change the information sent to the log. For example, if we want more information:</p>
<pre><code>$ python app.py --log-level DEBUG start foo
DEBUG start About to start foo
INFO start Started the 'foo' service.

$ python app.py --log-level DEBUG stop foo bar
DEBUG stop About to stop 'foo' and 'bar'
INFO stop Stopped the 'foo' and 'bar' services.

$ python app.py --log-level DEBUG restart foo bar baz
DEBUG restart About to restart 'foo', 'bar' and 'baz'
INFO restart Restarted the 'foo', 'bar' and 'baz' services.
</code></pre>
<p>And if we want less:</p>
<pre><code>$ python app.py --log-level WARNING start foo
$ python app.py --log-level WARNING stop foo bar
$ python app.py --log-level WARNING restart foo bar baz
</code></pre>
<p>In this case, the commands don’t print anything to the console, since nothing at <code>WARNING</code> level or above is logged by them.</p>
</section>
<section id="a-qt-gui-for-logging" class="level2">
<h2 class="anchored" data-anchor-id="a-qt-gui-for-logging">A Qt GUI for logging<a href="https://docs.python.org/3/howto/logging-cookbook.html#a-qt-gui-for-logging" title="Link to this heading">¶</a></h2>
<p>A question that comes up from time to time is about how to log to a GUI application. The <a href="https://www.qt.io/">Qt</a> framework is a popular cross-platform UI framework with Python bindings using <a href="https://pypi.org/project/PySide2/">PySide2</a> or <a href="https://pypi.org/project/PyQt5/">PyQt5</a> libraries.</p>
<p>The following example shows how to log to a Qt GUI. This introduces a simple <code>QtHandler</code> class which takes a callable, which should be a slot in the main thread that does GUI updates. A worker thread is also created to show how you can log to the GUI from both the UI itself (via a button for manual logging) as well as a worker thread doing work in the background (here, just logging messages at random levels with random short delays in between).</p>
<p>The worker thread is implemented using Qt’s <code>QThread</code> class rather than the <a href="https://docs.python.org/3/library/threading.html#module-threading" title="threading: Thread-based parallelism."><code>threading</code></a> module, as there are circumstances where one has to use <code>QThread</code>, which offers better integration with other <code>Qt</code> components.</p>
<p>The code should work with recent releases of any of <code>PySide6</code>, <code>PyQt6</code>, <code>PySide2</code> or <code>PyQt5</code>. You should be able to adapt the approach to earlier versions of Qt. Please refer to the comments in the code snippet for more detailed information.</p>
<pre><code>import datetime
import logging
import random
import sys
import time

# Deal with minor differences between different Qt packages
try:
    from PySide6 import QtCore, QtGui, QtWidgets
    Signal = QtCore.Signal
    Slot = QtCore.Slot
except ImportError:
    try:
        from PyQt6 import QtCore, QtGui, QtWidgets
        Signal = QtCore.pyqtSignal
        Slot = QtCore.pyqtSlot
    except ImportError:
        try:
            from PySide2 import QtCore, QtGui, QtWidgets
            Signal = QtCore.Signal
            Slot = QtCore.Slot
        except ImportError:
            from PyQt5 import QtCore, QtGui, QtWidgets
            Signal = QtCore.pyqtSignal
            Slot = QtCore.pyqtSlot

logger = logging.getLogger(__name__)


#
# Signals need to be contained in a QObject or subclass in order to be correctly
# initialized.
#
class Signaller(QtCore.QObject):
    signal = Signal(str, logging.LogRecord)

#
# Output to a Qt GUI is only supposed to happen on the main thread. So, this
# handler is designed to take a slot function which is set up to run in the main
# thread. In this example, the function takes a string argument which is a
# formatted log message, and the log record which generated it. The formatted
# string is just a convenience - you could format a string for output any way
# you like in the slot function itself.
#
# You specify the slot function to do whatever GUI updates you want. The handler
# doesn't know or care about specific UI elements.
#
class QtHandler(logging.Handler):
    def __init__(self, slotfunc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.signaller = Signaller()
        self.signaller.signal.connect(slotfunc)

    def emit(self, record):
        s = self.format(record)
        self.signaller.signal.emit(s, record)

#
# This example uses QThreads, which means that the threads at the Python level
# are named something like "Dummy-1". The function below gets the Qt name of the
# current thread.
#
def ctname():
    return QtCore.QThread.currentThread().objectName()


#
# Used to generate random levels for logging.
#
LEVELS = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,
          logging.CRITICAL)

#
# This worker class represents work that is done in a thread separate to the
# main thread. The way the thread is kicked off to do work is via a button press
# that connects to a slot in the worker.
#
# Because the default threadName value in the LogRecord isn't much use, we add
# a qThreadName which contains the QThread name as computed above, and pass that
# value in an "extra" dictionary which is used to update the LogRecord with the
# QThread name.
#
# This example worker just outputs messages sequentially, interspersed with
# random delays of the order of a few seconds.
#
class Worker(QtCore.QObject):
    @Slot()
    def start(self):
        extra = {'qThreadName': ctname() }
        logger.debug('Started work', extra=extra)
        i = 1
        # Let the thread run until interrupted. This allows reasonably clean
        # thread termination.
        while not QtCore.QThread.currentThread().isInterruptionRequested():
            delay = 0.5 + random.random() * 2
            time.sleep(delay)
            try:
                if random.random() &lt; 0.1:
                    raise ValueError('Exception raised: %d' % i)
                else:
                    level = random.choice(LEVELS)
                    logger.log(level, 'Message after delay of %3.1f: %d', delay, i, extra=extra)
            except ValueError as e:
                logger.exception('Failed: %s', e, extra=extra)
            i += 1

#
# Implement a simple UI for this cookbook example. This contains:
#
# * A read-only text edit window which holds formatted log messages
# * A button to start work and log stuff in a separate thread
# * A button to log something from the main thread
# * A button to clear the log window
#
class Window(QtWidgets.QWidget):

    COLORS = {
        logging.DEBUG: 'black',
        logging.INFO: 'blue',
        logging.WARNING: 'orange',
        logging.ERROR: 'red',
        logging.CRITICAL: 'purple',
    }

    def __init__(self, app):
        super().__init__()
        self.app = app
        self.textedit = te = QtWidgets.QPlainTextEdit(self)
        # Set whatever the default monospace font is for the platform
        f = QtGui.QFont('nosuchfont')
        if hasattr(f, 'Monospace'):
            f.setStyleHint(f.Monospace)
        else:
            f.setStyleHint(f.StyleHint.Monospace)  # for Qt6
        te.setFont(f)
        te.setReadOnly(True)
        PB = QtWidgets.QPushButton
        self.work_button = PB('Start background work', self)
        self.log_button = PB('Log a message at a random level', self)
        self.clear_button = PB('Clear log window', self)
        self.handler = h = QtHandler(self.update_status)
        # Remember to use qThreadName rather than threadName in the format string.
        fs = '%(asctime)s %(qThreadName)-12s %(levelname)-8s %(message)s'
        formatter = logging.Formatter(fs)
        h.setFormatter(formatter)
        logger.addHandler(h)
        # Set up to terminate the QThread when we exit
        app.aboutToQuit.connect(self.force_quit)

        # Lay out all the widgets
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(te)
        layout.addWidget(self.work_button)
        layout.addWidget(self.log_button)
        layout.addWidget(self.clear_button)
        self.setFixedSize(900, 400)

        # Connect the non-worker slots and signals
        self.log_button.clicked.connect(self.manual_update)
        self.clear_button.clicked.connect(self.clear_display)

        # Start a new worker thread and connect the slots for the worker
        self.start_thread()
        self.work_button.clicked.connect(self.worker.start)
        # Once started, the button should be disabled
        self.work_button.clicked.connect(lambda : self.work_button.setEnabled(False))

    def start_thread(self):
        self.worker = Worker()
        self.worker_thread = QtCore.QThread()
        self.worker.setObjectName('Worker')
        self.worker_thread.setObjectName('WorkerThread')  # for qThreadName
        self.worker.moveToThread(self.worker_thread)
        # This will start an event loop in the worker thread
        self.worker_thread.start()

    def kill_thread(self):
        # Just tell the worker to stop, then tell it to quit and wait for that
        # to happen
        self.worker_thread.requestInterruption()
        if self.worker_thread.isRunning():
            self.worker_thread.quit()
            self.worker_thread.wait()
        else:
            print('worker has already exited.')

    def force_quit(self):
        # For use when the window is closed
        if self.worker_thread.isRunning():
            self.kill_thread()

    # The functions below update the UI and run in the main thread because
    # that's where the slots are set up

    @Slot(str, logging.LogRecord)
    def update_status(self, status, record):
        color = self.COLORS.get(record.levelno, 'black')
        s = '&lt;pre&gt;&lt;font color="%s"&gt;%s&lt;/font&gt;&lt;/pre&gt;' % (color, status)
        self.textedit.appendHtml(s)

    @Slot()
    def manual_update(self):
        # This function uses the formatted message passed in, but also uses
        # information from the record to format the message in an appropriate
        # color according to its severity (level).
        level = random.choice(LEVELS)
        extra = {'qThreadName': ctname() }
        logger.log(level, 'Manually logged!', extra=extra)

    @Slot()
    def clear_display(self):
        self.textedit.clear()


def main():
    QtCore.QThread.currentThread().setObjectName('MainThread')
    logging.getLogger().setLevel(logging.DEBUG)
    app = QtWidgets.QApplication(sys.argv)
    example = Window(app)
    example.show()
    if hasattr(app, 'exec'):
        rc = app.exec()
    else:
        rc = app.exec_()
    sys.exit(rc)

if __name__=='__main__':
    main()
</code></pre>
</section>
<section id="logging-to-syslog-with-rfc5424-support" class="level2">
<h2 class="anchored" data-anchor-id="logging-to-syslog-with-rfc5424-support">Logging to syslog with RFC5424 support<a href="https://docs.python.org/3/howto/logging-cookbook.html#logging-to-syslog-with-rfc5424-support" title="Link to this heading">¶</a></h2>
<p>Although <a href="https://datatracker.ietf.org/doc/html/rfc5424.html"><strong>RFC 5424</strong></a> dates from 2009, most syslog servers are configured by default to use the older <a href="https://datatracker.ietf.org/doc/html/rfc3164.html"><strong>RFC 3164</strong></a>, which hails from 2001. When <code>logging</code> was added to Python in 2003, it supported the earlier (and only existing) protocol at the time. Since RFC5424 came out, as there has not been widespread deployment of it in syslog servers, the <a href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code>SysLogHandler</code></a> functionality has not been updated.</p>
<p>RFC 5424 contains some useful features such as support for structured data, and if you need to be able to log to a syslog server with support for it, you can do so with a subclassed handler which looks something like this:</p>
<pre><code>import datetime
import logging.handlers
import re
import socket
import time

class SysLogHandler5424(logging.handlers.SysLogHandler):

    tz_offset = re.compile(r'([+-]\d{2})(\d{2})$')
    escaped = re.compile(r'([\]"\\])')

    def __init__(self, *args, **kwargs):
        self.msgid = kwargs.pop('msgid', None)
        self.appname = kwargs.pop('appname', None)
        super().__init__(*args, **kwargs)

    def format(self, record):
        version = 1
        asctime = datetime.datetime.fromtimestamp(record.created).isoformat()
        m = self.tz_offset.match(time.strftime('%z'))
        has_offset = False
        if m and time.timezone:
            hrs, mins = m.groups()
            if int(hrs) or int(mins):
                has_offset = True
        if not has_offset:
            asctime += 'Z'
        else:
            asctime += f'{hrs}:{mins}'
        try:
            hostname = socket.gethostname()
        except Exception:
            hostname = '-'
        appname = self.appname or '-'
        procid = record.process
        msgid = '-'
        msg = super().format(record)
        sdata = '-'
        if hasattr(record, 'structured_data'):
            sd = record.structured_data
            # This should be a dict where the keys are SD-ID and the value is a
            # dict mapping PARAM-NAME to PARAM-VALUE (refer to the RFC for what these
            # mean)
            # There's no error checking here - it's purely for illustration, and you
            # can adapt this code for use in production environments
            parts = []

            def replacer(m):
                g = m.groups()
                return '\\' + g[0]

            for sdid, dv in sd.items():
                part = f'[{sdid}'
                for k, v in dv.items():
                    s = str(v)
                    s = self.escaped.sub(replacer, s)
                    part += f' {k}="{s}"'
                part += ']'
                parts.append(part)
            sdata = ''.join(parts)
        return f'{version} {asctime} {hostname} {appname} {procid} {msgid} {sdata} {msg}'
</code></pre>
<p>You’ll need to be familiar with RFC 5424 to fully understand the above code, and it may be that you have slightly different needs (e.g.&nbsp;for how you pass structural data to the log). Nevertheless, the above should be adaptable to your speciric needs. With the above handler, you’d pass structured data using something like this:</p>
<pre><code>sd = {
    'foo@12345': {'bar': 'baz', 'baz': 'bozz', 'fizz': r'buzz'},
    'foo@54321': {'rab': 'baz', 'zab': 'bozz', 'zzif': r'buzz'}
}
extra = {'structured_data': sd}
i = 1
logger.debug('Message %d', i, extra=extra)
</code></pre>
</section>
<section id="how-to-treat-a-logger-like-an-output-stream" class="level2">
<h2 class="anchored" data-anchor-id="how-to-treat-a-logger-like-an-output-stream">How to treat a logger like an output stream<a href="https://docs.python.org/3/howto/logging-cookbook.html#how-to-treat-a-logger-like-an-output-stream" title="Link to this heading">¶</a></h2>
<p>Sometimes, you need to interface to a third-party API which expects a file-like object to write to, but you want to direct the API’s output to a logger. You can do this using a class which wraps a logger with a file-like API. Here’s a short script illustrating such a class:</p>
<pre><code>import logging

class LoggerWriter:
    def __init__(self, logger, level):
        self.logger = logger
        self.level = level

    def write(self, message):
        if message != '\n':  # avoid printing bare newlines, if you like
            self.logger.log(self.level, message)

    def flush(self):
        # doesn't actually do anything, but might be expected of a file-like
        # object - so optional depending on your situation
        pass

    def close(self):
        # doesn't actually do anything, but might be expected of a file-like
        # object - so optional depending on your situation. You might want
        # to set a flag so that later calls to write raise an exception
        pass

def main():
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger('demo')
    info_fp = LoggerWriter(logger, logging.INFO)
    debug_fp = LoggerWriter(logger, logging.DEBUG)
    print('An INFO message', file=info_fp)
    print('A DEBUG message', file=debug_fp)

if __name__ == "__main__":
    main()
</code></pre>
<p>When this script is run, it prints</p>
<pre><code>INFO:demo:An INFO message
DEBUG:demo:A DEBUG message
</code></pre>
<p>You could also use <code>LoggerWriter</code> to redirect <code>sys.stdout</code> and <code>sys.stderr</code> by doing something like this:</p>
<pre><code>import sys

sys.stdout = LoggerWriter(logger, logging.INFO)
sys.stderr = LoggerWriter(logger, logging.WARNING)
</code></pre>
<p>You should do this <em>after</em> configuring logging for your needs. In the above example, the <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" title="logging.basicConfig"><code>basicConfig()</code></a> call does this (using the <code>sys.stderr</code> value <em>before</em> it is overwritten by a <code>LoggerWriter</code> instance). Then, you’d get this kind of result:</p>
<p>&gt;&gt;&gt;</p>
<pre><code>&gt;&gt;&gt; print('Foo')
INFO:demo:Foo
&gt;&gt;&gt; print('Bar', file=sys.stderr)
WARNING:demo:Bar
&gt;&gt;&gt;
</code></pre>
<p>Of course, the examples above show output according to the format used by <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" title="logging.basicConfig"><code>basicConfig()</code></a>, but you can use a different formatter when you configure logging.</p>
<p>Note that with the above scheme, you are somewhat at the mercy of buffering and the sequence of write calls which you are intercepting. For example, with the definition of <code>LoggerWriter</code> above, if you have the snippet</p>
<pre><code>sys.stderr = LoggerWriter(logger, logging.WARNING)
1 / 0
</code></pre>
<p>then running the script results in</p>
<pre><code>WARNING:demo:Traceback (most recent call last):

WARNING:demo:  File "/home/runner/cookbook-loggerwriter/test.py", line 53, in &lt;module&gt;

WARNING:demo:
WARNING:demo:main()
WARNING:demo:  File "/home/runner/cookbook-loggerwriter/test.py", line 49, in main

WARNING:demo:
WARNING:demo:1 / 0
WARNING:demo:ZeroDivisionError
WARNING:demo::
WARNING:demo:division by zero
</code></pre>
<p>As you can see, this output isn’t ideal. That’s because the underlying code which writes to <code>sys.stderr</code> makes multiple writes, each of which results in a separate logged line (for example, the last three lines above). To get around this problem, you need to buffer things and only output log lines when newlines are seen. Let’s use a slightly better implementation of <code>LoggerWriter</code>:</p>
<pre><code>class BufferingLoggerWriter(LoggerWriter):
    def __init__(self, logger, level):
        super().__init__(logger, level)
        self.buffer = ''

    def write(self, message):
        if '\n' not in message:
            self.buffer += message
        else:
            parts = message.split('\n')
            if self.buffer:
                s = self.buffer + parts.pop(0)
                self.logger.log(self.level, s)
            self.buffer = parts.pop()
            for part in parts:
                self.logger.log(self.level, part)
</code></pre>
<p>This just buffers up stuff until a newline is seen, and then logs complete lines. With this approach, you get better output:</p>
<pre><code>WARNING:demo:Traceback (most recent call last):
WARNING:demo:  File "/home/runner/cookbook-loggerwriter/main.py", line 55, in &lt;module&gt;
WARNING:demo:    main()
WARNING:demo:  File "/home/runner/cookbook-loggerwriter/main.py", line 52, in main
WARNING:demo:    1/0
WARNING:demo:ZeroDivisionError: division by zero
</code></pre>
</section>
<section id="patterns-to-avoid" class="level2">
<h2 class="anchored" data-anchor-id="patterns-to-avoid">Patterns to avoid<a href="https://docs.python.org/3/howto/logging-cookbook.html#patterns-to-avoid" title="Link to this heading">¶</a></h2>
<p>Although the preceding sections have described ways of doing things you might need to do or deal with, it is worth mentioning some usage patterns which are <em>unhelpful</em>, and which should therefore be avoided in most cases. The following sections are in no particular order.</p>
<section id="opening-the-same-log-file-multiple-times" class="level3">
<h3 class="anchored" data-anchor-id="opening-the-same-log-file-multiple-times">Opening the same log file multiple times<a href="https://docs.python.org/3/howto/logging-cookbook.html#opening-the-same-log-file-multiple-times" title="Link to this heading">¶</a></h3>
<p>On Windows, you will generally not be able to open the same file multiple times as this will lead to a “file is in use by another process” error. However, on POSIX platforms you’ll not get any errors if you open the same file multiple times. This could be done accidentally, for example by:</p>
<ul>
<li><p>Adding a file handler more than once which references the same file (e.g.&nbsp;by a copy/paste/forget-to-change error).</p></li>
<li><p>Opening two files that look different, as they have different names, but are the same because one is a symbolic link to the other.</p></li>
<li><p>Forking a process, following which both parent and child have a reference to the same file. This might be through use of the <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a> module, for example.</p></li>
</ul>
<p>Opening a file multiple times might <em>appear</em> to work most of the time, but can lead to a number of problems in practice:</p>
<ul>
<li><p>Logging output can be garbled because multiple threads or processes try to write to the same file. Although logging guards against concurrent use of the same handler instance by multiple threads, there is no such protection if concurrent writes are attempted by two different threads using two different handler instances which happen to point to the same file.</p></li>
<li><p>An attempt to delete a file (e.g.&nbsp;during file rotation) silently fails, because there is another reference pointing to it. This can lead to confusion and wasted debugging time - log entries end up in unexpected places, or are lost altogether. Or a file that was supposed to be moved remains in place, and grows in size unexpectedly despite size-based rotation being supposedly in place.</p></li>
</ul>
<p>Use the techniques outlined in <a href="https://docs.python.org/3/howto/logging-cookbook.html#multiple-processes">Logging to a single file from multiple processes</a> to circumvent such issues.</p>
</section>
<section id="using-loggers-as-attributes-in-a-class-or-passing-them-as-parameters" class="level3">
<h3 class="anchored" data-anchor-id="using-loggers-as-attributes-in-a-class-or-passing-them-as-parameters">Using loggers as attributes in a class or passing them as parameters<a href="https://docs.python.org/3/howto/logging-cookbook.html#using-loggers-as-attributes-in-a-class-or-passing-them-as-parameters" title="Link to this heading">¶</a></h3>
<p>While there might be unusual cases where you’ll need to do this, in general there is no point because loggers are singletons. Code can always access a given logger instance by name using <code>logging.getLogger(name)</code>, so passing instances around and holding them as instance attributes is pointless. Note that in other languages such as Java and C#, loggers are often static class attributes. However, this pattern doesn’t make sense in Python, where the module (and not the class) is the unit of software decomposition.</p>
</section>
<section id="adding-handlers-other-than-nullhandler-to-a-logger-in-a-library" class="level3">
<h3 class="anchored" data-anchor-id="adding-handlers-other-than-nullhandler-to-a-logger-in-a-library">Adding handlers other than <a href="https://docs.python.org/3/library/logging.handlers.html#logging.NullHandler" title="logging.NullHandler"><code>NullHandler</code></a> to a logger in a library<a href="https://docs.python.org/3/howto/logging-cookbook.html#adding-handlers-other-than-nullhandler-to-a-logger-in-a-library" title="Link to this heading">¶</a></h3>
<p>Configuring logging by adding handlers, formatters and filters is the responsibility of the application developer, not the library developer. If you are maintaining a library, ensure that you don’t add handlers to any of your loggers other than a <a href="https://docs.python.org/3/library/logging.handlers.html#logging.NullHandler" title="logging.NullHandler"><code>NullHandler</code></a> instance.</p>
</section>
<section id="creating-a-lot-of-loggers" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-lot-of-loggers">Creating a lot of loggers<a href="https://docs.python.org/3/howto/logging-cookbook.html#creating-a-lot-of-loggers" title="Link to this heading">¶</a></h3>
<p>Loggers are singletons that are never freed during a script execution, and so creating lots of loggers will use up memory which can’t then be freed. Rather than create a logger per e.g.&nbsp;file processed or network connection made, use the <a href="https://docs.python.org/3/howto/logging-cookbook.html#context-info">existing mechanisms</a> for passing contextual information into your logs and restrict the loggers created to those describing areas within your application (generally modules, but occasionally slightly more fine-grained than that).</p>
</section>
</section>
<section id="other-resources" class="level2">
<h2 class="anchored" data-anchor-id="other-resources">Other resources<a href="https://docs.python.org/3/howto/logging-cookbook.html#other-resources" title="Link to this heading">¶</a></h2>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/glennmatlin\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 Glenn Matlin. All rights reserved.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Published with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>